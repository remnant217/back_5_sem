# Интеграция с фронтендом 2
'''
План урока:
1) Протокол HTTP и когда его не хватает
2) Знакомство с протоколом WebSocket
3) Реализация чат-бота через WebSocket

СОВЕТ ПРЕПОДАВАТЕЛЮ: на курсе "Frontend-разработка. JavaScript" студенты создавали чат-бота
на HTML, CSS и JavaScript. Сегодня вы будете модифицировать этого бота и добавлять взаимодействие
с backend-ом через протокол WebSocket. Файлы index.html, style.css и script.js с исходной версией
бота можно найти в папке old_bot с доп. материалами. Версию бота с backend-ом можно найти в папке new_bot.
Убедитесь, что у студентов также есть файлы index.html, style.css и script.js с исходной версией бота.
'''

# ---------------------------------------------------------------------------------------------------------

# Протокол HTTP и когда его не хватает
'''
Ранее все наши приложения на FastAPI работали с протоколом HTTP, где основная модель
взаимодействия клиента и сервера - это "запрос-ответ". При этом:
1) Инициализатор всегда клиент - посылает запрос
2) Ответ от сервера - однократный. Нет "постоянного потока" ответов в рамках одной операции

То есть использование HTTP-запрос прекрасно подходит для CRUD-операций (получить список данных,
оформить заказ, загрузить профиль и т.д.).

Но использование протокола HTTP бывает не всегда оптимальным решением, вот примеры ситуаций:
1) Онлайн-игры - огромное количество данных постоянно передается от клиента к серверу и наоборот
2) Совместное редактирование документов - пользователи видят изменения документов в режиме реального времени
3) Чаты - сообщения приходят в любое время, нужен постоянный канал связи

Какие при этом могут возникать проблемы при использовании HTTP:
1) Либо мы не сразу видим изменения, либо делаем постоянные запросы в стиле:"А пришли какие-нибудь обновления?"
2) Высокая нагрузка - очень много пустых запросов при редких событиях
3) Появляется задержка между произошедшим событием и его обнаружением со стороны клиента

Эти проблемы можно решить с помощью других технологий, и одна из них - это протокол WebSocket, о котором
мы сейчас поговорим.
'''

# ---------------------------------------------------------------------------------------------------------

# Знакомство с протоколом WebSocket
'''
WebSocket - протокол, который позволяет устанавливать двустороннее соединение между клиентом и сервером
в режиме реального времени. В отличии от протокола HTTP, WebSocket работает с двунаправленным потоком данных.
Это значит, что можно передавать и получать информацию одновременно по одному открытому каналу.

Принцип работы WebSocket:
1) Клиент отправляет HTTP-запрос с заголовком Upgrade, указывая, что хочет установить соединение по WebSocket
2) Сервер возвращает ответ с кодом 101-Switching Protocols, указывая, что протокол переключается с HTTP на WebSocket
3) После установления соединения начинается двусторонний обмен данными - клиент или сервер могут отправлять данные
в любое время. Данные передаются в виде "фреймов" (текстовых или бинарных).
4) Когда клиент или сервер хочет закрыть соединение, отправляется закрывающий фрейм и соединение закрывается.

ВСТАВИТЬ ДИАГРАММУ "Цикл WebSocket-соединения"

WebSocket-соединения имеют определенный тип URL. Есть 2 варианта:
1) ws:// - для незашифрофанных соединений
2) wss:// - для зашифрованных соединений
Сегодня нам хватит и незашифрованного соединения.
'''

# ---------------------------------------------------------------------------------------------------------

# Реализация чат-бота через WebSocket
'''
На курсе "Frontend-разработка. JavaScript" вы создавали чат-бота на HTML, CSS и JavaScript.
Такой вариант бота вполне хорош для небольшого проекта, но для высоконагруженного бота логику
стоит перенести на сервер, в нашем случае - в FastAPI. Наша текущая задача - написать бэкенд для 
бота и подружить его с фронтендом через протокол WebSocket. Архитектуру проекта реализуем следующим образом:
'''

# Задание № 1 - выстроить архитектуру проекта

'''
new_bot/
├─ main.py
└─ static/
   ├─ index.html
   ├─ style.css
   └─ script.js

СОВЕТ ПРЕПОДАВАТЕЛЮ: убедитесь, что студенты сформировали такую структуру проекта.
ВАЖНО - проговорите студентам, чтобы они создали копии файлов index.html, style.css и script.js,
т.к. исходники им еще понадобятся на курсе по frontend-у.

Для простоты в main.py будем писать весь код FastAPI. 
В будущем, конечно, этот код можно разнести на отдельные модули.
'''

# Задание № 2 - реализовать файл main.py

# подключаем asyncio для реализации задержки бота (1.5 секунды) и запуска фоновой задачи
import asyncio
# WebSocket - класс для работы с протоколом WebSocket в FastAPI
# WebSocketDisconnect - класс для обработки разрыва WebSocket-соединений
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
# подключаем класс StaticFiles для работы с файлами HTML, CSS и JS
from fastapi.staticfiles import StaticFiles
# подключаем класс RedirectResponse чтобы при обращении к / происходил редирект на /static/index.html
from fastapi.responses import RedirectResponse

app = FastAPI()

# подключаем обработчик статических файлов из папки /static
app.mount('/static', StaticFiles(directory='./static'), name='static')

# функция для ответа пользователю (также, как в script.js)
def reply(user_text: str) -> str:
    t = (user_text or "").lower()
    if "привет" in t or "здравствуй" in t:
        return "Привет! Как твои дела?"
    if "погода" in t:
        return "Я пока не умею смотреть погоду, но скоро научусь!"
    if "имя" in t:
        return "Меня зовут Ботти."
    if "пока" in t or "до свидания" in t:
        return "До встречи! Хорошего дня!"
    return "Я не совсем понял. Можешь переформулировать?"

# корутина для имитации "Бот печатает..." и отправки ответа через WebSocket
async def process_and_reply(ws: WebSocket, text: str):
    # задержка печати в 1.5 секунды
    await asyncio.sleep(1.5)
    # send_text() - метод для отправки текстовых сообщений через WebSocket
    await ws.send_text(reply(text))

# обработка GET-запроса для перехода на страницу бота
@app.get('/')
def root():
    return RedirectResponse(url='/static/index.html')

# эндпоинт для работы с WebSocket-соединение
@app.websocket('/ws')
async def ws_endpoint(ws: WebSocket):
    # accept() - метод для начала работы WebSocket-соединения 
    await ws.accept()
    # открываем бесконечный цикл приема сообщений 
    # пока клиент подключен - будем читать и отвечать на сообщения
    try:
        while True:
            # receive_text() - метод, ожидающий получение текстового сообщения от клиента через WebSocket
            text = await ws.receive_text()
            # создаем фоновую задачу, так сервер может принимать новые сообщения
            asyncio.create_task(process_and_reply(ws, text))
    # ловим WebSocketDisconnect (клиент покинул чат) - освобождаем ресурсы и закрываем соединение
    except WebSocketDisconnect:
        pass

# Задание № 3 - модифицировать файл index.html

'''
Теперь подправим файл index.html, в данном коде:
<link rel="stylesheet" href="style.css">
<script src="script.js"></script>

укажем папку /static для корректной работе ссылок:
<link rel="stylesheet" href="/static/style.css">
<script src="/static/script.js"></script>
'''

# Задание № 4 - модифицировать файл script.js
'''
СОВЕТ ПРЕПОДАВАТЕЛЮ: здесь вам предстоит модифицировать код файла script.js - удалить некоторые элементы,
а затем добавить новый код для работы с WebSocket. Код для работы с WebSocket в JavaScript будет новым
для студентов, но не переживайте, сам код не очень сложный, а студенты знакомы с необходимым синтаксисом JS.

Итак, перейдем к модификации файла script.js:
1) Удалим строчку let typingTimer = null; - раньше задержка ответа была на стороне фронтенда,
теперь же она на стороне сервера.

2) Полностью удаляем функцию function getBotResponse(userText) - раньше логика ответа бота была на стороне фронтенда,
теперь же она на стороне сервера.

3) Добавляем минимальный JS-код для работы с WebSocket:
// Работа с веб-сокетом
// Если текущий сайт открыт по протоколу https - выбирается wss, иначе простой ws
const wsProtocol = location.protocol === 'https:' ? 'wss' : 'ws';
// Создаем новое WebSocket-соединение через шаблон <ws|wss>://<хост и порт текущей страницы>/ws
// В location.host лежит localhost:8000
const ws = new WebSocket(`${wsProtocol}://${location.host}/ws`);
// Ожидаем событие message - оно появляется, когда сервер прислал фрейм с данными
// e - событие с полезными данными
ws.addEventListener('message', (e) => {
    // Когда пришел ответ от сервера - прячем индикатор "Бот печатает..."
    if (isTyping) {
        isTyping = false;
        typingIndicator.style.display = 'none';
    }
    // Показываем сообщение бота, e.data содержит текст ответа бота
    // Ставим false, показывая, что сообщение от бота, а не от пользователя
    addMessage(e.data, false);
});

4) В функции function handleSendMessage() удаляем конструкцию
    if (typingTimer) {
        clearTimeout(typingTimer);
    }
Логика работы с таймером задержки теперь на бэкенде.

5) Также внутри функции function handleSendMessage() убираем функцию typingTimer = setTimeout(() => 
в текущем виде - вместо нее пишем проверку - если WebSocket-соединение открыто, то отправляем текст
пользователя на сервер. Если же соединение не готово или закрыто - прячем индикатор "Бот печатает..."
и Отправляем сообщение о недоступности сервера:
// 3) Отправляем текст на сервер по WebSocket
    if (ws.readyState === WebSocket.OPEN) {
        ws.send(userText);
    // Если соединение не готово или закрыто
    } else {
        // Прячем индикатор "Бот печатает..."
        isTyping = false;
        typingIndicator.style.display = 'none';
        // Отправляем сообщение о недоступности сервера
        addMessage('Сервер недоступен. Попробуйте позже.', false);
    }

6) Финальная правка - в функции function clearChatHistory() убираем все, что связано с typingTimer
и оставляем только скрытие индикатор "Бот печатает...":
// Функция для очистки истории чата
function clearChatHistory() {
    // Скрываем индикатор, если был
    if (isTyping) {
        isTyping = false;
        typingIndicator.style.display = 'none';
    }

Все готово, все файлы модифицированы! Теперь можно запускать и тестировать бота. 
'''