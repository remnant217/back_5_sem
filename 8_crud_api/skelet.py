# Работа с CRUD API

'''
План урока:
1) Введение
2) Теория CRUD API
3) Подготовка проекта
4) Работа с schemas.py
5) Работа с data_store.py
6) Работа с main.py
7) Заключение
'''

# -------------------------------------------------------------------------------------------------------------

# Теория CRUD API
'''
Современные полноценные API позволяют работать с различными HTTP-запросами, не только с GET и POST.
Ведь данные можно не только создавать и получать, но также обновлять и удалять.
Для работы с подобными операциями разработчики создают так называемые CRUD API.

CRUD - это аббревиатура из 4 английских слов, описывающих базовые операции с данными:
- C - Create (создать)
- R - Read (читать)
- U - Update (обновить)
- D - Delete (удалить)

Эти операции можно применять к любым хранилищам данных.

CRUD-операции на примере блокнота:
Create - создать новую заметку
Read - прочитать заметку
Update - дописать или изменить заметку
Delete - вырвать страницу с заметкой

Каждая CRUD-операция в веб-приложении реализуется через определенный HTTP-метод:
| CRUD-операция | HTTP-метод | Назначение                                     | Пример URL           |
| ------------- | ---------- | ---------------------------------------------- | -------------------- |
| Create        | POST       | Создание нового ресурса                        | POST /items          |
| Read          | GET        | Получение списка ресурсов                      | GET /items           |
| Read          | GET        | Получение конкретного ресурса по ID            | GET /items/{id}      |
| Update        | PUT        | Полное обновление ресурса (замена всех данных) | PUT /items/{id}      |
| Update        | PATCH      | Частичное обновление (только указанные поля)   | PATCH /items/{id}    |
| Delete        | DELETE     | Удаление ресурса                               | DELETE /items/{id}   |

Важно понимать разницу между PUT и PATCH:
1) PUT - полная замена объекта.
Например, если в объекте есть поля name, price, description и мы передали только name и price,
то поле description может стать пустым.

2) PATCH - частичное обновление объекта.
Изменяются только те поля, которые переданы в запросе, остальные остаются без изменений.
В прошлом примере при работе метода PATCH поле description осталось бы с предыдущим значением.

Пример с блокнотом:
PUT - переписать целую страницу в блокноте
PATCH - вписать одно слово, не трогая остальное

При работе с CRUD API часто встречаются различные ошибки, которые могут возникать при работе клиента с нашим приложением. 
Вот самые популярные из них:
1. 404 Not Found 
2. 400 Bad Request е
3. 422 Unprocessable Entity 
4. 409 Conflict 
5. 500 Internal Server Error 
По кодам данных ошибок клиент узнает о результатах своего запроса и определяет, какие действия ему предпринимать дальше.
'''

# Задание № 1 - разобрать небольшой пример CRUD-операций через товары в интернет-магазине
'''
1. Создание (Create) - клиент отправляет на сервер POST-запрос с JSON-файлом:
{
  "name": "Ноутбук",
  "price": 55000
}
Сервер возвращает объект с новым ID (например, 2).

2. Чтение (Read) - клиент отправляет GET-запрос:
- /items - получение списка всех товаров
- /items/2 - получение товара с ID=2

3. Обновление (Update):
- клиент отправляет PATCH-запрос - обновляются некоторые поля объекта:
{
  "name": "Ноутбук",
  "price": 60000
}
- клиент отправляет PUT-запрос - объект полностью заменяется:
{
  "name": "Телефон",
  "price": 40000
}

4. Удаление (Delete) - клиент отправляет DELETE-запрос на /items/2 и объект удаляется.

Важный момент - сегодня мы не будет подключать БД, данные будут храниться в памяти программы.
Так мы сосредоточимся на правильной организации CRUD-операций, валидации входящих данных 
и работе с HTTP-методами. Уже совсем скоро мы на курсе мы будем говорить про SQLAlchemy и SQLite, 
и тогда подключим наш CRUD API к настоящей БД.
'''

# -------------------------------------------------------------------------------------------------------------

# Подготовка проекта
'''
Далее мы будем создавать API для работы с каталогом товаров.
Для описания товара мы будем работать с сущностью Product, которая хранит следующие поля:
- id - уникальный идентификатор товара
- name - название товара
- description - описание товара
- price - стоимость товара
- in_stock - товар в наличии или нет
'''

# Задание № 2 - разбить проект на отдельные модули
'''
Ранее на курсе, в рамках воркшопа, мы учились разбивать проект на отдельные слои и модули.
Пришло время применить эти знания уже в контексте FastAPI.
Создадим папку product_catalog/ и модули нашего проекта:
product_catalog/
├─ main.py           # эндпоинты с реализацией CRUD-операций
├─ schemas.py        # Pydantic-схемы для запросов/ответов
├─ data_store.py     # временное хранилище в памяти

Таким образом, в main.py будем хранить эндпоинты с реализацией CRUD-операций, 
в schemas.py - валидацию данных о товарах через Pydantic,
в data_store.py - "псевдо-БД" с товарами.
'''

# Задание № 3 - создать виртуальное окружение и сохранить зависимости проекта
'''
python -m venv venv
venv\Scripts\activate
pip install fastapi uvicorn
pip freeze > requirements.txt
'''

# -------------------------------------------------------------------------------------------------------------

# Работа с schemas.py
'''
Начнем с модуля schemas.py, где опишем Pydantic-схемы под разные случаи (создание, вывод и частичное обновление товара).
Если будем использовать только одну схему для всего, то будут проблемы с безопасностью, гибкостью и документацией API.
'''
from pydantic import BaseModel, Field

# Задание № 4 - реализовать класс ProductCreate

# схема для создания товара
class ProductCreate(BaseModel):
    # обязательное поле длиной от 1 до 200 символов
    name: str = Field(min_length=1, max_length=200)
    # необязательное поле, может быть строкой или объектом None
    description: str | None = None
    # обязательное поле, цена должна быть > 0
    price: float = Field(gt=0)
    # необязательное поле, по умолчанию True (если клиент не прислал - считаем, что товар "в наличии")
    in_stock: bool = True

# Задание № 5 - реализовать класс Product

# схема ответа (что возвращаем клиенту), наследуемся от ProductCreate
class Product(ProductCreate):
    # ID добавляем только в ответ клиенту (генерируется на стороне БД)
    id: int

# Задание № 6 - реализовать класс ProductUpdate

# схема для обновления данных о товаре
class ProductUpdate(BaseModel):
    # все поля опциональны - клиент может прислать только то, что хочет изменить
    # если поле не прислано вовсе - оно считается 'unset', важно для будущего эндпоинта
    # default=None - поле может быть передано как null
    name: str | None = Field(default=None, min_length=1, max_length=200)
    description: str | None = None
    price: float | None = Field(default=None, gt=0)
    # значение по умолчанию делаем None, а не True, чтобы при PATCH-запросе, если клиент
    # не прислал in_stock, оно не считалось присланным как True, что может привести к путанице
    in_stock: bool | None = None
'''
Таким образом, если использовать всего один класс вместо трех (все поля в одном месте, ID тоже),
то будут проблемы, например:
- Создание товара - пользователь будет обязан передать ID и все поля, даже если БД должна генерировать ID сама
- Обновление товара - придется передавать все поля, даже если меняется только одно
- Ответ API - модель запроса и модель ответа будут совпадать, что создает путаницу и мешает валидации
'''

# -------------------------------------------------------------------------------------------------------------

# Работа с data_store.py

# Задание № 7 - реализовать класс DataStore
'''
Перейдем к data_store.py, где опишем класс с временным хранилище данных.
Состоять он будет из инициализатора со словарем товаров и счетчиком ID, 
а также метода для увеличения счетчика ID на 1:
'''
from schemas import Product

# класс для реализации хранилища товаров
class DataStore:
    def __init__(self):
        # инициализация словаря с товарами и счетчика ID
        self.products: dict[int, Product] = {}
        self.current_id: int = 1
    
    # метод для увеличения значения счетчика ID на 1
    def next_id(self) -> int:
        value = self.current_id
        self.current_id += 1
        return value

# создаем экземпляр DataStore
store = DataStore()

# -------------------------------------------------------------------------------------------------------------

# Работа с main.py
'''
Осталось оформить main.py со всеми эндпоинтами для реализации CRUD-операций к нашему API.
В будущем мы будем разносить данные функции по разным модулям в соответствии с их логикой и назначением,
но сейчас пока сосредоточимся именно на CRUD-операциях и как их реализовать с учетом написанного ранее кода. 
'''

# Задание № 8 - прописать необходимые начальные импорты (все, кроме List и HTTPException) 
from fastapi import FastAPI, HTTPException
from typing import List
# подключаем все компоненты из созданных ранее модулей
from schemas import ProductCreate, Product, ProductUpdate
from data_store import store

app = FastAPI()

# Задание № 12 - реализовать вспомогательную функцию get_product_or_404()
# вспомогательная функция для получения товара по ID (если товара нет - возвращает статус 404)
def get_product_or_404(product_id: int) -> Product:
    product = store.products.get(product_id)
    if not product:
        raise HTTPException(status_code=404, detail='Товар не найден')
    return product

# Задание № 9 - реализовать эндпоинт root()
# эндпоинт для обработки GET-запроса к корневому элементу (базовая проверка работы приложения)
@app.get('/')
def root():
    return {'message': 'API каталога товаров готов к работе'}

# Задание № 10 - реализовать эндпоинт create_product()
# эндпоинт для обработки POST-запроса на создание нового товара
# response_model - определяет структуру ответа, возвращаемого эндпоинтом
@app.post('/products', response_model=Product)
def create_product(product_data: ProductCreate):
    # передаем в модель значения полей для создания нового товара
    product = Product(id=store.next_id(), **product_data.model_dump())
    store.products[product.id] = product
    return product

# Задание № 11 - подключить typing.List и реализовать эндпоинт get_products_list()
# эндпоинт для получения списка со всеми товарами
@app.get('/products', response_model=List[Product])
def get_products_list():
    return list(store.products.values())

# Задание № 13 - реализовать эндпоинт get_product()
# эндпоинт для обработки GET-запроса на получение товара по ID
@app.get('/products/{product_id}', response_model=Product)
def get_product(product_id: int):
    return get_product_or_404(product_id)

# Задание № 14 - реализовать эндпоинт put_product()
# эндпоинт для обработки PUT-запроса на полную замену данных о товаре по ID
@app.put('/products/{product_id}', response_model=Product)
def put_product(product_id: int, product_data: ProductCreate):
    # проверка наличия товара (если нет - функция завершит свою работу)
    _ = get_product_or_404(product_id)
    updated = Product(id=product_id, **product_data.model_dump())
    store.products[product_id] = updated
    return updated

# Задание № 15 - реализовать эндпоинт patch_product()
# эндпоинт для обработки PATCH-запроса на частичное обновление данных о товаре по ID
@app.patch('/products/{product_id}', response_model=Product)
def patch_product(product_id: int, product_data: ProductUpdate):
    current = get_product_or_404(product_id)
    # exclude_unset=True - меняем только присланные поля
    updates = product_data.model_dump(exclude_unset=True)
    # model_copy() - возвращает копию Pydantic-модели
    product_data_updated = current.model_copy(update=updates)
    store.products[product_id] = product_data_updated
    return product_data_updated

# Задание № 16 - реализовать эндпоинт delete_product()
# эндпоинт для обработки DELETE-запроса на удаление данных о товаре по ID
@app.delete('/products/{product_id}')
def delete_product(product_id: int):
    _ = get_product_or_404(product_id)
    del store.products[product_id]
    return {'message': 'Товар удален'}