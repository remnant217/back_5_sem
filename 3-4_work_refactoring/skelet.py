# Воркшоп. Практика рефакторинга и структуры проекта

# Введение
'''
На прошлом уроке мы посмотрели, как выглядит хорошая структура проекта
и из каких слоев он может состоять. Сегодня мы посмотрим на то, 
как иногда начинается разработка в реальности - с неоформленного, монолитного кода.
И будем учиться превращать такой код в качественную архитектуру.

СОВЕТ ПРЕПОДАВАТЕЛЮ: в этой методичке содержатся материалы сразу для двух уроков – 3 и 4. 
Можете адаптировать тайминг и контент исходя из уровня студентов, 
чтобы начать работу на Встрече 3 и закончить на Встрече 4.
'''

# -------------------------------------------------------------------------------------------------

# Анализ "плохого" кода
'''
Одна из главных вещей, которыми мы будем сегодня заниматься, это рефакторинг.

Рефакторинг - процесс изменения внутренней структуры кода без изменения его внешнего поведения.

С помощью рефакторинга мы улучшаем уже существующий код:
- Делаем его понятнее
- Делим на модули
- Убираем повторения
- Повышаем читаемость и поддерживаемость

Важно понимать, что рефакторинг - это часть реальной разработки и всегда используется 
при создании больших и качественных проектов.

Рефакторинг можно сравнить с ремонтом в квартире. Представьте, что вы живете у себя дома,
и базово, вроде как, все хорошо: свет горит, вода из крана течет и т.д. Но в один момент
вы понимаете: мебель стоит неудобно, проводов на видном месте слишком много, 
плитка в ванной отклеилась, шкаф мешает открывать дверь в команду и т.д.
В такой ситуации вы вряд ли будете переезжать в другую квартиру, а просто начнете 
приводить все в порядок - переставлять, чинить и обновлять. Также и рефакторинг - 
это улучшение внутреннего устройства программы, без изменения ее поведения снаружи.

На предыдущем занятии мы смотрели на пример проекта с менеджером заметок,
а затем разделяли его на отдельные модули. Сейчас нас ждет похожая задача,
но теперь мы знаем о слоях архитектуры проекта и понимаем важность рефакторинга.

Сейчас мы будем работать с проектом калькулятора расходов. Он записывает траты, 
считает общую сумму, сохраняет и загружает данные из файла. И все работает. 
Но при этом весь код находится в одном файле, а мы уже знает, что по мере роста 
такого проекта поддержка и добавление новых фич будут все сложнее и сложнее.

Наша задача - проанализировать текущий код и подумать, как можно улучшить его структуру.
В этом и заключается рефакторинг - мы не будем писать все с нуля,
а приведем текущий код в порядок с определенными модификациями.

СОВЕТ ПРЕПОДАВАТЕЛЮ: у студентов в ЛК есть ссылка на файл с данным кодом.
В доп. материалах к уроку также есть этот файл с кодом (expense_calc.py).
Попросите студентов скачать к себе данный файл. Рекомендуется сначала очень быстро
пройтись по всему кода, а затем вместе со студентами постепенно рассматривать
обсуждать возможные проблемы. Обязательно задействуйте студентов при обсуждении проблем кода.
'''

# список для хранения трат в виде словарей
expenses = []

# главный цикл, внутри которого собран весь код приложения
while True:
    # отображение возможных команд для пользователя
    print("1. Добавить трату")
    print("2. Показать все траты")
    print("3. Показать сумму")
    print("4. Сохранить в файл")
    print("5. Загрузить из файла")
    print("6. Выйти")

    # ввод команды со стороны пользователя
    choice = input("Выбор: ")

    # ввод и сохранение информации об одной трате
    if choice == "1":
        amount = float(input("Введите сумму: "))
        category = input("Введите категорию: ")
        expenses.append({"amount": amount, "category": category})

    # вывод на экран информации о всех тратах
    elif choice == "2":
        for e in expenses:
            print(f"{e['amount']} руб — {e['category']}")
    
    # подсчет и вывод на экран общей суммы всех трат
    elif choice == "3":
        total = sum(e["amount"] for e in expenses)
        print(f"Всего потрачено: {total} руб.")
    
    # сохранение данных о тратах в файл
    elif choice == "4":
        with open("expenses.txt", "w", encoding="utf-8") as f:
            for e in expenses:
                f.write(f"{e['amount']}|{e['category']}\n")
        print("Сохранено.")
    
    # выгрузка всех данных о тратах из файла
    elif choice == "5":
        expenses = []
        with open("expenses.txt", encoding="utf-8") as f:
            for line in f:
                amount, category = line.strip().split("|")
                expenses.append({"amount": float(amount), "category": category})
        print("Загружено.")
    
    # завершение работы 
    elif choice == "6":
        break

    # обработка некорректной команды
    else:
        print("Некорректная команда. Попробуйте снова.")

# Проблемы представленного кода:

# 1. Список трат
'''
expenses = []

Мы храним траты в виде словарей. При этом не указано никакой структуры,
просто словари с двумя ключами.
'''

# 2. Главный цикл
'''
while True:
    print("\n1. Добавить трату")
    ...

В главном цикле содержится весь код приложения. Это и интерфейс,
и контроллер, и бизнес-логика - все в одном месте.
'''

# 3. Добавление трат
'''
if choice == "1":
        amount = float(input("Введите сумму: "))
        category = input("Категория: ")
        expenses.append({"amount": amount, "category": category})

Видим нарушение сразу нескольких принципов хорошей архитектуры:
- Ввод данных происходит прямо в логике
- Траты сохраняются в виде словаря, без единой модели данных
- Нет обработки ошибок при полученнии данных от пользователя
'''

# 4. Сохранение/выгрузка данных
'''
elif choice == "4":
    with open("expenses.txt", "w", encoding="utf-8") as f:
    ...

elif choice == "5":
    expenses = []
    with open("expenses.txt", encoding="utf-8") as f:
    ...
    
Вся логика работы с файловой системой происходит в точке входа в программу.
'''

# -------------------------------------------------------------------------------------------------

# Описание структуры проекта

'''
Сейчас мы будем разбивать и преобразовывать рассмотренный ранее код. 
Для начала выделим основные архитектурные слои и сделаем разбивку по модулям.

Какие основные архитектурные слои вы помните?

К основным слоям можно отнести логику (logic), модель (models), хранилище (storage).
К дополнительным можно отнести контроллер (controller).
Также в проект мы добавим папку с тестами (tests) для тестирования кода
из модулей основных слоев (logic, models, storage).

Обновленная структура нашего проекта будет выглядеть так:
expense_calc/
├── main.py                  # точка входа
├── controller/
│   ├── cli.py               # ввод и вывод информации о тратах через терминал
│   └── menu.py              # меню пользователя с управляющим циклом
├── logic/
│   └── statistics.py        # логика калькулятора (подсчет суммы расходов)
├── models/
│   └── expense.py           # структура трат в виде класса
├── storage/
│   └── file_storage.py      # работа с файлами (загрузка и выгрузка данных)
├── tests/
│   ├── test_expense.py      # тестирование модели трат 
│   ├── test_statistics.py   # тестирование логики калькулятора
│   └── test_file_storage.py # тестирование сохранения/загрузки данных 

СОВЕТ ПРЕПОДАВАТЕЛЮ: выделите время, чтобы студенты у себя создали проект по указанной структуре.
В ЛК есть ссылка на пустой шаблон данного проекта (expense_calc_template), в доп. материалах к 
уроку шаблон тоже есть. Студенты могут воспользоваться данным шаблоном, либо создать все папки
и файлы с нуля, главное - не терять много времени от занятия.
'''

# -------------------------------------------------------------------------------------------------

# Оформление models/expense.py
'''
Создадим отдельную структуру данных для одной траты с помощью класса 
под названием Expense.
'''
class Expense:
    def __init__(self, amount: float, category: str):
        '''
        Аннотация типов - способ указать ожидаемые типы данных для переменных, 
        аргументов и возвращаемых значений, чтобы сделать код понятнее, безопаснее
        и удобнее для разработки. Аннотация типов не подразумевает строгую проверку
        во время выполнения, при этом можно использовать специальные инструменты для
        валидации типов, о них поговорим дальше на курсе. Мы указали, что в amount
        ожидается сохранение дробного числа (float), а в category - сохранение строки (str).
        '''
        self.amount = amount
        self.category = category
    
    def __str__(self):
        '''
        Строковое представление объекта. 
        Позволяет красиво печатать объект в терминал информацию о трате.
        Например:"300 руб - Продукты"
        '''
        return f'{self.amount} руб - {self.category}'

    def to_line (self) -> str:
        '''
        Преобразует объект в строку для записи в файл.
        Символ || выбран как разделитель, чтобы избежать путаницы с другими символами.
        Аннотация -> str показывает, что метод возвращает строку.
        '''
        return f'{self.amout}||{self.category}'
    
    '''
    @staticmethod - декоратор для объявления статического метода внутри класса.
    Такой метод не принимает self, не зависит от состояния экземпляра класса и
    может вызываться напрямую как Класс.метод() или экземпляр.метод(), но без передачи self.
    Применяется когда метод логически связан с классом, но не использует его данные.
    '''
    @staticmethod
    def from_line(line: str) -> 'Expense':
        '''
        Преобразует строку из файла (например "123.5||Продукты") обратно в объект Expense.
        Аннотация -> 'Expense' указана в кавычках, чтобы тип подставился позже,
        т.к. класс еще не завершен в момент создания данного метода.
        '''
        amount_str, category = line.strip().split('||')
        return Expense(float(amount_str), category)
    
# -------------------------------------------------------------------------------------------------

# Создание tests/test_expense.py
'''
Мы создали класс для описания модели трат, теперь оформим файл 
с простым тестом данного класса.
'''
# подключаем класс Expense из созданного ранее модуля
from models.expense import Expense

# функция для тестирования преобразования объекта Expense в строку и обратно
def test_to_line_and_back():
    # создаем тестовые данные и проверяем методы to_line(), from_line()
    exp_origin = Expense(220, 'Еда')
    line = exp_origin.to_line()
    exp_result = Expense.from_line(line)

    # если значения amount и category исходного объекта равны значениям результата - тест пройден
    if exp_origin.amount == exp_result.amount and exp_origin.category == exp_result.category:
        print('test_to_line_and_back: PASSED')
    # иначе - тест не пройден и выводим пояснение
    else:
        print('test_to_line_and_back: FAILED')
        print(f'Ожидалось: amount={exp_origin.amount}, category={exp_origin.category}')
        print(f'Получено: amount={exp_result.amount}, category={exp_result.category}')

# запускаем тест
if __name__ == '__main__':
    test_to_line_and_back()

'''
ВАЖНЫЙ МОМЕНТ: не стоит запускать test_expense.py напрямую из папки tests, т.к. из-за этого
сломаются импорты и появятся ошибки. Чтобы все было корректно, нам нужно находиться в корне проекта
и выполнить следующую команду в терминале:

python -m tests.test_expense.py

Так мы запустим test_expense.py как модуль внутри пакета tests. 
Тогда импорты вроде from models.expense import Expense будут работать правильно.
Указанный флаг -m означает, что мы запускаем модуль с учетом его положения в структуре пакетов.
Если бы мы запустили вот такую команду, без -m:

python tests.test_expense.py

то Python считал бы test_expense.py обычным скриптом и не видел остальные директории (models) как пакеты.
В результате появлялась бы ошибка ModuleNotFoundError.

СОВЕТ ПРЕПОДАВАТЕЛЮ: остальные тесты в рамках занятия запускайте в такой же логике,
через pythom -m tests.<файл_с_тестом>.py.
'''

# -------------------------------------------------------------------------------------------------

# Оформление logic/statistics.py
'''
Все траты внутри программы мы будем хранить в списке.
Создадим отдельную функцию для подсчета суммы всех трат.
'''
# принимает список с тратами и возвращает их общую сумму в виде дробного числа
def get_total(expenses) -> float:
    return sum(exp.amount for exp in expenses)

'''
В дальнейшем этот модуль можно дополнять другими функциями для посчета и анализа трат.
'''
# -------------------------------------------------------------------------------------------------

# Создание tests/test_statistics.py
'''
Модуль с простой логикой калькулятора готов, теперь также оформим файл с простым тестом.
'''
# подключаем класс Expense и функцию get_total()
from logic.statistics import get_total
from models.expense import Expense

# функция для тестирования подсчета общей суммы по нескольким тратам
def test_get_total():
    # создаем тестовые данные и проверяем функцию get_total()
    expenses = [Expense(100, "Еда"), Expense(50, "Транспорт")]
    expected = 150
    actual = get_total(expenses)

    # если ожидаемая и рассчитанная суммы совпали - тест пройден
    if expected == actual:
        print('test_get_total: PASSED')
    # иначе - тест не пройден, выводим пояснение
    else:
        print('test_get_total: FAILED')
        print(f'Ожидалось значение суммы {expected}, получено {actual}')

# запускаем тест
if __name__ == '__main__':
    test_get_total()

# -------------------------------------------------------------------------------------------------

# Оформление storage/file_storage.py
'''
Теперь реализуем модуль file_storage.py для сохранения данных о тратах в текстовый файл,
а также выгрузки данных из файла.
'''
# подключаем класс Expense
from models.expense import Expense

# переменная для хранения имени файла
FILENAME = 'expenses.txt'

# функция для сохранения трат в файл, принимает список с объектами класса Expense
def save_expenses(expenses: list[Expense]):
    # открываем поток работы с файлом и записываем в него траты, каждую с новой строки
    with open(FILENAME, 'w', encoding='utf-8') as f:
        for exp in expenses:
            f.write(exp.to_line() + '\n')

# функция для загрузки трат из файла, возвращает список с объектами класса Expense
def load_expenses() -> list[Expense]:
    # список для загрузки данных
    expenses = []
    # пробуем открыть поток работы с файлом и сохранить данные в список
    try:
        with open(FILENAME, encoding='utf-8') as f:
            for line in f:
                expenses.append(Expense.to_line(line))
    # если файл не найден - вернем пустой список
    except FileNotFoundError:
        pass
    # возвращаем список с объектами класса Expense
    return expenses

# -------------------------------------------------------------------------------------------------

# Создание tests/test_file_storage.py
'''
Реализуем последний тест в нашем проекте, чтобы проверить корректность
работы модуля file_storage.py.
'''
# подключаем класс Expense и функции save_expenses(), load_expenses()
from models.expense import Expense
from storage.file_storage import save_expenses, load_expenses

# функция для тестирования сохранения в файл и загрузки из файла
def test_save_and_load():
    # создаем тестовые данные и проверяем функции save_expenses(), load_expenses()
    expenses = [
        Expense(100, 'Развлечения'),
        Expense(50, 'Другое')
    ]
    save_expenses(expenses)
    loaded = load_expenses()

    # если количество сохраненных и загруженных элементов не совпало - тест не пройден
    if len(loaded) != len(expenses):
        print('test_save_and_load: FAILED')
        print(f'Элементов сохранено: {len(expenses)}, загружено: {len(loaded)}')
    # иначе - тест пройден
    else:
        print('test_save_and_load: PASSED')

# запускаем тест
if __name__ == '__main__':
    test_save_and_load()

# -------------------------------------------------------------------------------------------------

# Оформление controller/cli.py
'''
Теперь создадим модуль для ввода и вывода информации о расходах через терминал.
Важно учесть:
1) При вводе суммы трат нужно реализовать проверку корректности (введено неотрицательное число).
2) При выводе работаем со списком, в который уже загружены данные.
Если же данных еще нет - сообщаем об этом пользователю.
'''
# подключаем класс Expense для оформления аннотации типов
from models.expense import Expense

# функция для ввода информации о трате через терминал, возвращает кортеж с дробным числом и строкой
def input_expense() -> tuple[float, str]:
    # запрашиваем сумму траты, пока не получим корректное значение
    while True:
        # проверяем, что введено неотрицательное число
        try:
            amount = float(input('Введите сумму:'))
            if amount < 0:
                raise ValueError('Сумма траты не должна быть отрицательной')
            break
        # показываем ошибку при некорректном вводе
        except ValueError as err:
            print(f'Ошибка: {err}')

    # запрашиваем категорию траты
    category = input('Введите категорию:')
    # возвращаем кортеж с суммой и категорией траты
    return amount, category

# функция для отображения данных о тратах в терминале
def print_expensess(expenses: list[Expense]):
    # если данные о тратах еще не выгружены в программу
    if not expenses:
        print('Нет данных для отображения')
        return
    
    # построчный вывод трат в терминал с разделением для удобства восприятия
    print('Список трат:')
    print('-' * 30)
    # нумерацию начинаем с 1 для удобства пользователя
    for ind, exp in enumerate(expenses, start=1):
        print(f'{ind}. {exp.amount} руб. - {exp.category}')
    print('-' * 30)
'''
Теперь вся логика ввода и вывода информации о тратах через терминал вынесена в отдельный модуль.
Если будет необходимо сделать полноценный графический интерфейс - достаточно заменить
данный модуль на другой.
'''

# -------------------------------------------------------------------------------------------------

# Файлы menu.py и main.py
'''
На данный момент нам осталось оформить только menu.py с объединением всех частей приложения
и main.py как точку входа в программу. Реализация этих файлов пойдем вам в качестве самостоятельной
работы дома и вот небольшие подсказки:
1) menu.py
- общая структура кода будет как в изначальном, монолитном варинте проекта - while True и
6 возможных команд
- при выборе команды запускается соответствующая функция из подходящего слоя
- весь код находится внутри функции, которую потом можно запустить в main.py

2) main.py
- запуск функции из menu.py

СОВЕТ ПРЕПОДАВАТЕЛЮ: в доп. материалах находится полный вариант проекта, с оформленными файлами
menu.py и main.py. Можете опираться на них, чтобы давать доп. рекомендации студентам.
'''

# -------------------------------------------------------------------------------------------------

# Заключение
'''
Сегодня мы проделали действительно колоссальную работу. У нас был монолитный код, который мы разбили
на модули и отдельные слои - модель данных (models), бизнес-логику (logic) и хранилище (storage),
при этом оформив небольшие тесты, которые хранятся в отдельной папке (tests).
Также мы разделили ввод и вывод данных через терминал (cli.py), а управляющий цикл оформили 
как отдельный контроллер (menu.py).
Не стоит забывать, что мы посмотрели на новый для нас инструмент языка Python - аннотацию типов.
В будущем мы будем применять ее довольно часто.

Важно помнить, что хороший проект похож на здание. Если его строить из одной кучи кирпичей
без продуманной структуры - это может работать какое-то время, но рано или поздно здание разрушится. 
Если же в здании есть комнаты и этажи (модули и слои), то в таком доме можно жить, 
масштабироваться и работать в команде.

На следующем занятии мы начнем работу с фреймворком FastAPI, где будем постепенно применять
полученные знания о хорошей архитектуре. До встречи!
'''