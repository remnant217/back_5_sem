# В этом файле содержится весь материал с Занятия 2 "Архитектура проектов".

# Архитектура проектов

'''
План занятия:
1) Введение (5 минут)
2) Важность архитектуры проекта (15 минут)
3) Принципы хорошей архитектуры (25 минут)
4) Виртуальное окружение и requirements.txt (15 минут)
5) Архитектурные слои (10 минут)
6) Куда отнести код? (15 минут)
7) Заключение (5 минут)
'''

# Введение
'''
На прошлом занятии мы повторяли синтаксис Python, функции, модули и классы. 
Также мы немного говорили о том, как организовывать код в отдельных файлах (main.py и utils.py).
Сегодня мы пойдем чуть дальше и поговорим о том, как выстраивать архитектуру целого проекта. 
Без этого знания в современном программировании не обходится ни один проект, особенно в backend-разработке.

Вопросы для повторения материала:
1) За что отвечает backend-разработка?
Ответ: создание внутренней логики приложения, работа с БД, обработка запросов от клиента

2) Как называется .py-файл, который можно импортировать и использовать в своем проекте?
Ответ: модуль

3) За что отвечает конструкция if __name__ == '__main__'?
Ответ: указанный внутри блок кода будет выполняться только при прямом запуске файла, 
а не при его импорте как модуля.
'''

# ----------------------------------------------------------------------------------------------------------------------------------

# Важность архитектуры проекта
'''
Чтобы понимать важность и необходимость работы с архитектурой проекта, посмотрим на следующий пример.
Представим, что у разработчика была задача - создать простое консольное приложение для работы с заметками.
Приложение должно уметь:
- добавлять новую заметку (заголовок и текст)
- показывать все заметки
- сохранять все заметки в текстовый файл
СОВЕТ ПРЕПОДАВАТЕЛЮ: студентам не нужно переписывать этот код, главная задача - посмотреть, 
проанализировать и определить возможные проблемы.
'''

def add_note():
    title = input("Введите заголовок: ")
    text = input("Введите текст: ")
    note = f"{title}|{text}\n"
    with open("notes.txt", "a", 
              encoding="utf-8") as f:
        f.write(note)

def show_notes():
    with open("notes.txt", encoding="utf-8") as f:
        for line in f:
            title, text = line.strip().split("|")
            print(f"{title} → {text}")

def run():
    while True:
        print("1. Добавить 2. Показать 3. Выйти")
        cmd = input("Выберите команду: ")
        if cmd == "1":
            add_note()
        elif cmd == "2":
            show_notes()
        elif cmd == "3":
            break
        else:
            print("Ошибка")

run()

'''
Сейчас этот файл выглядит для нас вполне привычно. Но если посмотреть внимательно и подумать:
- Какие операции указаны в этом коде?
В коде одновременно реализуются несколько разных задач - ввод данных пользователя, 
создание и форматирование заметки, запись заметки в файл и вывод интерфейса пользователя.

- Можно ли повторно использовать функцию add_note() в другом проекте?
Это будет проблематично, т.к. add_note() напрямую зависит логики функций input(), open(),
и от структуры файла notes.txt

- Как можно написать тест для функции show_notes()?
Реализовать грамотное тестирование будет сложно, т.к. show_notes() сама открывает файл 
и печатает данные в терминал. При этом, в текущей конфигурации функции мы не можем 
грамотно подставить тестовые данные для проверки. Ко всему прочему, функция не возвращает значение,
а только выводит результат на экран, что сильно осложняет тестирование.

- Насколько удобно будет работать с этим кодом, если функций станет больше (например, 20)?
С ростом кода будет сложнее понять, что от чего зависит и какая функция зависит от другой.

Видим проблему - при увеличении объемов проекта, хранить все в одном файле становится очень неудобно.
Представьте, что вы переехали в новый дом и положили посуду, книги, одежду и инструменты в один шкаф.
Кажется, что вы это сделали довольно быстро - просто положили все в одно место, без лишних раздумий. 
Но проблема в том, что теперь очень сложно найти нужную вам книгу или одежду, когда все перемешано.
Также и с программным кодом без структуры - его можно относительно быстро составить,
но довольно сложно поддерживать в будущем.

Таким образом, сегодня мы познакомимся с тем, как правильно организовывать проект, чтобы:
- было понятно, где искать нужный код
- можно было работать с командой разработчиков в единой логике
- была возможность удобно тестировать и сопровождать проект
Эти знания также окажутся для нас максимально полезны и необходимы в будущем при работе с FastAPI.
'''

# ---------------------------------------------------------------------------------------------------------

# Принципы хорошей архитектуры
'''
Ранее мы увидели, что хранить вообще всю логике в одном файле - такая себе затея.
Теперь давайте посмотрим на принципы, которые позволяют создавать понятный и масштабируемый код.

| Принцип                           | Пояснение                                                                                             |
| --------------------------------- | ------------------------------------------------------------------------------------------------------|
| 1. Разделение ответственности     | Каждый модуль отвечает за одну задачу                                                                 |
| 2. Один файл - одна роль          | Если файл делает и ввод, и логику, и запись — это плохо. Лучше:                                       |
|                                   | controller.py - общение с пользователем, note_logic.py - логика заметок, storage.py - работа с файлами|
| 3. "Сверху вниз"                  | main.py вызывает контроллер, тот - логику, логика - хранилище, обратного вызова нет                   |
| 4. Переиспользуемость             | Один и тот же модуль можно использовать в другом проекте или тесте                                    |
| 5. Читабельность                  | Структура проекта как оглавление книги: видно, что и где искать                                       |

Теперь возьмем прошлый код из main.py и разобьем его на отдельные файлы. Новая структура проекта будет выглядеть так:
- main.py - точка входа в программу
- controller.py - ввод команд со стороны пользователя
- note_logic.py - логика работы с заметками
- storage.py - работа с файлами

СОВЕТ ПРЕПОДАВАТЕЛЮ: старайтесь максимально задействовать учеников при при оформлении кода в отдельных файлах.
Убедитесь, что все ученики поняли логику распределения и осознали для чего это нужно.

Код в main.py:
from controller import run

if __name__ == "__main__":
    run()

Код в controller.py:
from note_logic import add_note, show_notes

def run():
    while True:
        print("1. Добавить 2. Показать 3. Выйти")
        cmd = input("Выберите команду: ")
        if cmd == "1":
            title = input("Заголовок: ")
            text = input("Текст: ")
            add_note(title, text)
        elif cmd == "2":
            show_notes()
        elif cmd == "3":
            break
            
Код в note_logic.py:
from storage import save_to_file, load_from_file

def add_note(title, text):
    note = f"{title}|{text}"
    save_to_file(note)

def show_notes():
    for raw in load_from_file():
        title, text = raw.strip().split("|")
        print(f"{title}: {text}")

Код в storage.py:
def save_to_file(text):
    with open("notes.txt", "a", encoding="utf-8") as f:
        f.write(text + "\n")

def load_from_file():
    with open("notes.txt", encoding="utf-8") as f:
        return f.readlines()

При запуске файла main.py и тестировании программы вызов функций будет выглядеть следующим образом:
main.py
  │
  ▼
controller.run()
  ├──► note_logic.add_note()
  │       └──► storage.save_to_file()
  │
  └──► note_logic.show_notes()
          └──► storage.load_from_file()
'''

# ----------------------------------------------------------------------------------------------------------------------------------

# Виртуальное окружение и requirements.txt
'''
При разработке программных продуктов каждый разработчик пишет код на своем компьютере. 
Представим, что у меня установлена библиотека requests с версией 2.32.4, 
а у вас - 2.31.0. И возникла ситуация, что код с моей версией библиотеки запускается,
а тот же код, но с вашей версией - не запускается. Подобная проблема может возникнуть
из-за несовместимости версий библиотек. А значит полагаться на глобально установленные
библиотеки не всегда надежно.

В качестве решения проблемы можно создать виртуальное окружение.

Виртуальное окружение - изолированная среда, в которой можно устанавливать и использовать
собственный набор библиотек и зависимостей, независимо от глобального окружения системы.

Когда виртуальное окружение создано, мы устанавливаем нужные библиотеки именно туда.
После чего очень полезно создать специальный файл requirements.txt, где будут перечислены
все установленные библиотеки в рамках текущего проекта. Так каждый разработчик будет знать
какую библиотеку и какой версии нужно установить. Название файла requirements.txt является
общепринятым соглашением среди разработчиков.

Алгоритм создания и активации виртуального окружения

В терминале:
1) Создание виртуального окружения
python -m venv venv

2.1) Активация (Windows)
venv\Scripts\activate

2.2) Активация (macOS/Linux)
source venv/bin/activate

venv - встроенный инструмент в Python, создающий папку со своей копией Python-интерпретатора.
После активации мы устанавливаем библиотеки только в эту папку. Имя папки 'venv' не является
обязательным, но принято среди разработчиков. 
Если видим в терминале слева надпись (venv) - значит мы работаем внутри виртуального окружения.
Важный момент - при работе с Git-ом папку venv не стоит добавлять в репозиторий проекта, 
т.к. она большая по размеру, привязана к конкретной системе 
и легко воссоздается с помощью файла requirements.txt.

Теперь попробуем установить стороннюю библиотеку в наше виртуальное окружение, например requests:
pip install requests

Если мы зайдем в папку venv -> Lib\site-packages, то увидим установленные компоненты requests.

Сохраним текущие зависимости нашего проекта в файл requirements.txt:
pip freeze > requirements.txt

В папке с нашим проектом появился файл requirements.txt, если откроем его, то увидим примерно следующее:
certifi==2025.6.15
charset-normalizer==3.4.2
idna==3.10
requests==2.32.4
urllib3==2.4.0

Теперь у нас есть список зависимостей нашего проекта. 
Обратите внимание, что при работе с Git-ом файл requirements.txt принято класть в репозиторий проекта, 
чтобы любой участник команды разработки мог установить все необходимое. 

Для установки зависимостей из файла requirements.txt нужно выполнить следующую команду в терминале:
pip install -r requirements.txt

Теперь, при создании нового проекта, достаточно положить в папку файл requirements.txt, выполнить команду выше
и все нужные библиотеки установятся в виртуальное окружение.

СОВЕТ ПРЕПОДАВАТЕЛЮ: если позволяет время, создайте новый проект с виртуальным окружение и покажите процесс
установки библиотек с помощью файла requirements.txt.

Таким образом, использование виртуального окружения и работа с файлом requirements.txt 
позволяют backend-разработчикам создавать качественные проекты, с которыми удобно работать в команде,
а также разворачивать у себя на сервере. Также использование этих инструментов является неотъемлемой частью
архитектуры современных приложений, в этом мы будем убеждаться все сильнее, по мере работы на курсе.
''' 

# ----------------------------------------------------------------------------------------------------------------------------------

# Архитектурные слои

'''
Представим, что мы нашли интересный проект на GitHub и хотим быстро понять его общую структуру. 
Если архитектура проекта хорошо организована, то и разобраться с его логикой будет не так сложно.
Рассмотрим проект консольного менеджера заметок со следующей структурой:

project/
├── main.py
├── controller/
│   └── menu.py
├── logic/
│   └── notes.py
├── storage/
│   └── file_storage.py
├── models/
│   └── note.py
├── utils/
│   └── formatting.py
├── requirements.txt
├── README.md

Мы видим разбиение не только на отдельные файлы, но и на отдельные папки, что логично при расширении проекта.
1) main.py - точка входа в программу
2) controller/ - все, что связано с взаимодействием с пользователем (ввод команд, меню пользователя)
3) logic/ - бизнес-логика: добавление, редактирование, фильтрация заметок
4) storage/ - хранение данных: сейчас это может быть txt, потом можно заменить на sqlite или json
5) models/ - описание модели/структуры данных (например, класс Note для моделирования объекта заметки)
6) utils/ - доп. функции, не относящиеся напрямую к бизнес-логике (например, форматирование заметок)
7) requirements.txt - зависимости проекта
8) README.md - инструкция к проекту

Из рассмотренного примера видно, что каждая папка отвечает за свою задачу - кто-то общается с пользователем, 
кто-то обрабатывает данные, кто-то сохраняет их. При этом папки четки разделены, а не перемешаны, 
будто слои начинки в пироге. Подобный подход называется "Многоуровневая архитектура (layered architecture)":

| Слой                                  | Назначение                                                   | Примеры файлов            |
| -----------------------------------   | ------------------------------------------------------------ | ------------------------- |
| Контроллер (Presentation layer/API)   | Принимает входящие запросы и возвращает ответы               | controller/menu.py        |
| Бизнес-логика (Business/Service Layer)| Основная логика приложения, правила, проверки                | logic/notes.py            |
| Хранилище (Data Access Layer)         | Работа с базой данных, файлами, внешними хранилищами         | storage/file_storage.py   |
| Модели (Domain/Model Layer)           | Сущности предметной области, бизнес-объекты                  | models/note.py            |
| Утилиты (Utility Layer)               | Доп. функции, не относящиеся напрямую к бизнес-логике        | utils/formatting.py       |

В зависимости от проектов, количество слоев может отличаться, мы на это будем смотреть в течение курса.
Подобную архитектуру мы будем выстраивать в будущем, при работе с FastAPI, но не сразу, а постепенно.
Использование подобного подхода позволяет легко заменить, протестировать и использовать повторно любую часть кода.
'''

# ----------------------------------------------------------------------------------------------------------------------------------

# Куда отнести код?
'''
Теперь мы знаем, что в проекте с многоуровневой архитектурой каждый слой отвечает за свою задачу.
Давайте посмотрим на примеры кода из проекта консольного менеджера заметок и решим, в какой слой их отнести.
'''

# 1) Взаимодействие с пользователем
def ask_task_title():
    return input("Введите задачу: ")

# Ответ: controller, ведется работа с вводом данных от пользователя

# 2) Чтение из файла
def load_all():
    with open("tasks.txt", encoding="utf-8") as f:
        return f.readlines()

# Ответ: storage, функция считывает данные из хранилища (текстового файла)

# 3) Структура задачи
class Task:
    def __init__(self, text, done=False):
        self.text = text
        self.done = done

# Ответ: models, класс Task определяет модель/структуру данных

# 4) Логика фильтрации
def get_completed_tasks(tasks):
    return [task for task in tasks if task.done]

# Ответ: logic, функция отбирает задачи по заданному критерию (выполненные)

# 5) Форматирование вывода
def format_task(task):
    return f"[{'x' if task.done else ' '}] {task.text}"

# Ответ: utils, это вспомогательная функция, не влияющая на логику и хранение данных

# 6) Сохранение задачи
def save_task(task):
    with open("tasks.txt", "a", encoding="utf-8") as f:
        f.write(task.text + "\n")

# Ответ: storage, функция сохраняет задачу в хранилище (текстовый файл)

# 7*) Точка входа в программу
if __name__ == "__main__":
    run()

# Ответ: main.py, это точка входа в программу, не относится ни к одному архитектурному слою

# ----------------------------------------------------------------------------------------------------------------------------------

# Заключение
'''
На сегодняшнем занятии мы посмотрели на архитектуру проектов в backend-разработки,
обсудили принципы хорошей архитектуры и посмотрели на основные слои многоуровневой архитектуры.
Также мы научились создавать виртуальное окружение для своих проектов
и сохранять зависимости в файл requirements.txt. В конце мы потренировались в соотнесении 
фрагмента кода и соответствующего уровня архитектуры.
'''