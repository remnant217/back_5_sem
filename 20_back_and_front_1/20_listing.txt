# Интеграция с фронтендом 1

# Как связаны frontend и backend
'''
Сегодня мы впервые посмотрим на то, как соединяются вместе frontend- и backend-составляющие веб-приложения.
Даже если в будущем вы планируете заниматься только backend-разработкой, очень важно понимать,
как браузер принимает данные от пользователя, отправляет их в backend, получает ответ и показывает 
пользователю итоговый результат. 

Посмотрим на следующий пример, где пользователь заполняет форму для нового товара:
1) Пользователь на сайте заполняет форму товара - название, стоимость, модель, цвет и т.д.
2) Пользовать нажимает кнопку "Отправить данные". После этого данные отправляются на сервер
с помощью POST-запроса через JavaScript.
3) Backend обрабатывает полученные данные, сохраняет их в БД и возвращает ответ,
например, в формате JSON {"message": "Товар успешно создан!"}.
4) Frontend получает ответ и отображает соответствующее сообщение пользователю,
либо перенаправляет его на другую страницу.

РАЗВЕРНУТЬ ПО ГОРИЗОНТАЛИ И ПОКАЗАТЬ В ПРЕЗЕНТАЦИИ
+-------------------------------------------------------------------------------------------+
:                                   ВЕБ-ПРИЛОЖЕНИЕ                                          :
:                                                                                           :
:  [Пользователь в браузере]                                                                :
:        |                                                                                  :
:        | 1) Заполняет форму (название, цена, модель, цвет...)                             :
:        |                                                                                  :
:        v                                                                                  :
:  [HTML-страница + JS (Frontend)]                                                          :
:        |                                                                                  :
:        | 2) Нажатие "Отправить" → JS сериализует данные в JSON                            :
:        |    и делает fetch()                                                              :
:        |                                                                                  :
:        | .......... POST /api/products  (JSON body)  ..................................>  :
:        |             Headers: Content-Type: application/json                              :
:        |                                                                                  :
:        |                                                                                  :
:                                         [Backend (FastAPI)]                               :
:                                             |                                             :
:                                             | 3) Принимает JSON, валидирует (Pydantic)     :
:                                             |    формирует модель "ProductCreate"          :
:                                             v                                             :
:                                         [Сервис/Логика]                                   :
:                                             |                                             :
:                                             | 4) Готовит запись продукта                   :
:                                             |                                             :
:                                             v                                             :
:                                         [Хранилище/Репозиторий]                           :
:                                             |                                             :
:                                             | .......... INSERT ........................>  :
:                                             |            (создание записи в БД)           :
:                                             v                                             :
:                                         [База данных]                                     :
:                                             |                                             :
:                                             | <......... OK / новая запись (id) ......... :
:                                             v                                             :
:                                         [Backend (FastAPI)]                               :
:                                             |                                             :
:                                             | 5) Формирует ответ JSON                      :
:                                             |    { "message": "Товар успешно создан!",     :
:                                             |      "id": 123 }                             :
:                                             |                                             :
:        | <......... 201 Created  (JSON)  ................................................. :
:        |                                                                                  :
:  [HTML-страница + JS (Frontend)]                                                          :
:        |                                                                                  :
:        | 6) JS парсит ответ → показывает уведомление                                      :
:        |    или делает redirect на страницу товара/списка                                 :
:        v                                                                                  :
:  [Пользователь видит результат]                                                           :
+-------------------------------------------------------------------------------------------+
'''

# ---------------------------------------------------------------------------------------------------

# Подготовка структуры проекта
'''
Сегодня наше соединение frontend-а и backend-а будет проходить на примере мини-каталога с товарами.
У нас будет главная страница, откуда можно будет перейти на страницу с списком имеющихся товаров,
а также на форму для добавления нового товара. Страницы представляют из себя HTML-файлы, на которые 
мы скоро взглянем, а сейчас оформим каркас нашего проекта.
'''

# Задание № 1 - оформить каркас проекта

'''
СОВЕТ ПРЕПОДАВАТЕЛЮ: у студентов в предыдущем семестре был курс по работе с HTML и CSS, сейчас
студенты изучают JavaScript. Учитывайте это при работе на занятии.

├─ main.py                  # точка входа в приложение
├─ routers/
│  └─ products.py           # эндпоинты
└─ static/                  # статические файлы
    ├─ index.html           # главная страница
    ├─ products.html        # список товаров
    ├─ add_product.html     # форма для добавления товара
    └─ styles.css           # CSS-стили

В папке static/ у нас хранятся так называемые "статические" файлы, которые сервер просто отдает
клиенту, без обработки и логики. Такое название является общепринятым в веб-разработке.

Заготовки с HTML- и CSS-файлами у нас уже есть, давайте пройдемся по каждому из них
и в общих чертах обсудим содержимое.
'''

# Задание № 2 - рассмотреть содержимое статических файлов

'''
СОВЕТ ПРЕПОДАВАТЕЛЮ: в личном кабинете, в теории к занятию, у студентов есть ссылка на данные
статические файлы. Напомните студентам ЗАРАНЕЕ, чтобы они скачали эти файлы к себе.
Если у студентов есть проблемы с загрузкой файлов по ссылке из личного кабинете - отправьте
файлы в чат группы.
При просмотре статических файлов не нужно слишком подробно объяснять их содержимое,
иначе можно потерять слишком много времени.

index.html - стартовая страница с кратким заголовком и навигацией по двум ссылкам: «Список товаров» и «Добавить товар». 

<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Каталог товаров</title>
  <link rel="stylesheet" href="/static/styles.css" />
</head>
<body class="container">
  <h1>Каталог</h1>
  <p><a class="button" href="/static/products.html">Список товаров</a></p>
  <p><a class="button" href="/static/add_product.html">Добавить товар</a></p>
</body>
</html>

products.html - страница со структурой таблицы для отображения списка товаров. 

<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Список товаров</title>
  <link rel="stylesheet" href="/static/styles.css" />
</head>
<body class="container">
  <header>
    <h1>Список товаров</h1>
    <nav>
      <a href="/static/index.html">Главная</a>
      <a href="/static/add_product.html">Добавить</a>
    </nav>
    <hr />
  </header>

  <table>
    <thead><tr><th>#</th><th>Название</th><th>Цена</th><th>Остаток</th></tr></thead>
    <tbody>
      <tr><td>1</td><td>Ноутбук</td><td>79 990</td><td>5</td></tr>
      <tr><td>2</td><td>Клавиатура</td><td>2 990</td><td>12</td></tr>
    </tbody>
  </table>
</body>
</html>

add_product.html — форма добавления товара (поля: название, цена, остаток). 
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Добавить товар</title>
  <link rel="stylesheet" href="/static/styles.css" />
</head>
<body class="container">
  <header>
    <h1>Новый товар</h1>
    <nav>
      <a href="/static/index.html">Главная</a>
      <a href="/static/products.html">Список</a>
    </nav>
    <hr />
  </header>

  <form>
    <label>Название: <input type="text" placeholder="Например: Мышка" /></label>
    <label>Цена: <input type="number" min="0" step="0.01" /></label>
    <label>Остаток: <input type="number" min="0" /></label>
    <button type="button">Отправить</button>
  </form>

</body>
</html>

styles.css - минимальные стили для базовой типографики, сетки контейнера и таблиц.

:root { 
    font-family: system-ui, sans-serif; 
}

.container { 
    max-width: 900px; 
    margin: 0 auto; 
    padding: 1rem; 
}

table { 
    width: 100%; 
    border-collapse: collapse; 
    margin-top: .5rem; 
}

th, td { 
    border-bottom: 1px solid #e5e7eb; 
    padding: .5rem; 
    text-align: left; 
}

.button { 
    padding: .5rem .75rem; 
    border: 1px solid #cbd5e1; 
    border-radius: .5rem; 
    text-decoration: none; 
}

label { 
    display:block; 
    margin:.5rem 0; 
}

.hint { 
    color: #666; 
    font-size: .9rem; 
}

form {
  display: flex;
  flex-direction: column; 
  gap: .75rem;            
  align-items: flex-start;
}

Со статическими файлами разобрались, теперь перейдем к FastAPI. 
Начнем с файла routers/products.py, где создадим роутер и эндпоинт,
который обрабатывает GET-запрос к корневому каталогу.
'''

# Задание № 3 - оформить файл routers/products.py

from fastapi import APIRouter
# RedirectResponse - класс, перенаправляющий клиента на другой URL
from fastapi.responses import RedirectResponse

router = APIRouter()

@router.get('/')
async def root():
    # переадресация на страницу index.html
    return RedirectResponse(url='/static/index.html')

'''
Теперь пойдем к файлу main.py, где подключим папку со статическими файлами и созданный роутер.
'''

# Задание № 4 - оформить файл main.py

from fastapi import FastAPI
# StaticFiles - класс для работы со статическими файлами
from fastapi.staticfiles import StaticFiles
# подключаем роутер из файла routers/products.py
from routers.products import router

app = FastAPI()

# mount() - метод, позволяющий "вмонтировать под-приложение" в основное FastAPI-приложение
# добавляем папку со статическими файлами под именем static
app.mount(
    path='/static',
    app=StaticFiles(directory='./static'),
    name='static'
)

# подключаем роутер
app.include_router(router=router)

'''
Все готово! При запуске приложения, когда мы перейдем по адресу http://127.0.0.1,
то попадем на страницу http://127.0.0.1:8000/static/index.html, откуда мы можем
попасть на остальные страницы. Супер, теперь наше FastAPI-приложение умеет
работать со статическими файлами!
'''

# ---------------------------------------------------------------------------------------------------

# Знакомство с шаблонизатором Jinja2
'''
Jinja2 - шаблонизатор, позволяющий создавать текстовые файлы (.html, .csv, .txt и т.д.)
на основе одного или нескольких шаблонов. В шаблоне указаны места подстановки значений
с помощью переменных и конструкций, которые управляют логикой обработки данных.

Основная идея использования Jinja2 в том, что Python генерирует данные,
а шаблоны Jinja2 определяют, как они отображаются. То есть мы сможем прямо в HTML-файле
указывать необходимые шаблонные конструкции, куда будут подгружаться данные со стороны Python.
'''

# Задание № 5 - установить Jinja2
'''
Jinja2 является сторонней библиотекой, поэтому сначала ее необходимо установить:

pip install jinja2

Документация Jinja2: https://jinja.palletsprojects.com/en/stable/templates/
'''

# Задание № 6 - создать папку /templates

'''
Перед использованием Jinja2 создадим еще одну папку с названием templates. 
Туда мы постепенно будем перемещать наши HTML-файлы после шаблонизирования их с помощью Jinja2.
'''

# Задание № 7 - подключить Jinja2 в routers/products.py

'''
Теперь пойдем в файл routers/products.py и подключим Jinja2 вместе с другими доп. инструментами:
'''
# подключаем класс Request для корректной работы с запросами
from fastapi import APIRouter, Request
# HTMLResponse - класс, позволяющий возвращать HTML-содержимое из эндпоинта
from fastapi.responses import RedirectResponse, HTMLResponse
# Jinja2Templates - класс, позволяющий встраивать динамические данные в HTML-шаблоны
from fastapi.templating import Jinja2Templates

router = APIRouter()
# создаем менеджер шаблонов и указываем путь, где лежат HTML-шаблоны
templates = Jinja2Templates(directory='./templates')

# псевдо-БД с данными
products_db: list[dict] = [
    {'id': 1, 'title': 'Ноутбук', 'price': 79990, 'stock': 5},
    {'id': 2, 'title': 'Клавиатура', 'price': 2990, 'stock': 12},
    {'id': 3, 'title': 'Наушники', 'price': 1990, 'stock': 10}
]

# через response_class явно указываем, что ответ от сервера будет в виде HTML
@router.get('/', response_class=HTMLResponse)
async def root():
    return RedirectResponse(url='/static/index.html')

# обработка запроса на получение списка товаров
@router.get('/products', response_class=HTMLResponse)
# request нужен для корректной работы с шаблонами Jinja2
async def get_products_list(request: Request):
    # TemplateResponse - метод для отображения данных шаблонами Jinja2
    return templates.TemplateResponse(
        # name - имя файла в папке с шаблонами
        name='products.html',
        # context - словарь с переменными, которые будут доступны в HTML-файле
        context={'request': request, 'products': products_db}
    )

'''
Что будет происходить, когда пользователь открывается /products:
1) FastAPI вызывает get_products_list(), передавая внутрь request
2) Собирается словарь {'request': request, 'products': products_db}
3) Метод TemplateResponse подставляет значения из словарь в нужные места products.html
4) Клиент получает ответ с заполненным products.html
'''

# ---------------------------------------------------------------------------------------------------

# Преобразование products.html
'''
Итак, начнем преобразование наших статических HTML-файлов в шаблоны с применением Jinja2.
Первым на очереди - products.html. 
'''

# Задание № 8 - переместить products.html в папку /templates

'''
Переместим его из папки /static в созданную ранее папку /templates.
'''

# Задание № 9 - внедрить Jinja2 в код файла products.html

'''
Важно понимать, что данные из products_db пока что не подтягиваются в products.html и 
сейчас мы это будем исправлять. В файле products.html перейдем к коду, где указаны товары:

    <tbody>
      <tr><td>1</td><td>Ноутбук</td><td>79 990</td><td>5</td></tr>
      <tr><td>2</td><td>Клавиатура</td><td>2 990</td><td>12</td></tr>
    </tbody>

Сейчас мы заменим явно указанные строки с товарами на цикл, который будет проходиться по нашей БД
с товарами и подставлять соответствующие значения в нужный столбец таблицы. Выглядеть это будет так:
СОВЕТ ПРЕПОДАВАТЕЛЮ: здесь и далее - показывая очередную конструкцию Jinja2, объясняйте что это и зачем нужно.
Можете также посылить, что синтаксис Jinja2 местами очень напоминает Python.

    <tbody>
      {% for p in products %}
      <tr>
        <td>{{ p.id }}</td>
        <td>{{ p.title }}</td>
        <td>{{ p.price }}</td>
        <td>{{ p.stock }}</td>
      </tr>
      {% endfor %}
    </tbody>

Конструкции Jinja2:
{% for ... %}{% endfor %} - блок цикла, генерирует повторяющиеся HTML-фрагменты
{{ ... }} - указание переменной с последующей подстановкой в HTML

Теперь таблица будет формироваться по данным из нашей БД products-db. Но пока что страница
products.html не будет открываться при нажатии на кнопку "Список товаров" на главной странице.
Связано это с тем, что мы переместили products.html в папку templates/, а путь до products.html 
в index.html указан старый. Мы это поправим попозже, не переживайте. Но это не значит, что мы
не можем протестировать измененный products.html уже сейчас. Запустим наше приложение
и перейдем по адресу http://127.0.0.1:8000/products. В результате отобразятся наши товары из products_db.
Если мы внесем изменения в products_db - добавим товар или удалим - и перезагрузим страницу в браузере,
то обновленные данные подтянутся в табличку!

Давайте возвращаться к products.html и Jinja2.  Например, мы можем добавить проверку, есть ли в списке товары. 
Если товаров нет, то будем отображать текст "Товаров пока нет". Сделать это можно следующим образом:

  {% if products|length == 0 %}
    <p>Товаров пока нет</p>
  {% else %}
    <table>
    ...
    </table>
  {% endif %}

Конструкции Jinja2:
{% if ... %}{% else %}{% endif %} - блоки с условиями
|length - фильтр, возвращает длину списка

Теперь, если мы удалим в коде products_db удалим все записи, запустим приложение
и перейдем по адресу http://127.0.0.1:8000/products, то увидим подпись "Товаро пока нет".
Если в коде products_db вернуть записи обратно и перезагрузить страницы, то таблица
с товарами снова отобразится.

Продолжая тему фильтров - мы можем преобразовать цену товара и остаток в целые числа
на стороне Jinja2:

          <td>{{ p.price | int }}</td>
          <td>{{ p.stock | int }}</td>

Инструменты Jinja2:
| int - фильтр преобразования к целому числу
Существуют и другие фильтры, о них можно почитать в документации.
'''

# ---------------------------------------------------------------------------------------------------

# Преобразование add_product.html

# Задание № 10 - добавить новые эндпоинты в routers/products.py
'''
Теперь перейдем к работе с add_product.html. Для начала в routers/products.py добавим 2 эндпоинта: 
- обработка GET-запроса на получение формы создания товара
- обработка POST-запроса на создание товара
'''
# Form - класс для работы с данными из формы
from fastapi import Form
...
# обработка GET-запроса на получение формы создания товара
@router.get('/products/new', response_class=HTMLResponse)
async def get_new_product_form(request: Request):
    return templates.TemplateResponse(
        name='add_product.html',
        context={'request': request}
    )

# обработка POST-запроса на создание товара
@router.post('/products/create')
async def create_product(
    # указываем, что параметры придут из формы и выставляем ограничения
    title: str = Form(min_length=2),
    price: float = Form(ge=0),
    stock: int = Form(ge=0)
):
    # генерируем ID для нового товара
    next_id = max((p['id'] for p in products_db), default=0) + 1
    # добавляем новый товар в псевдо-БД
    products_db.append({
        'id': next_id,
        'title': title,
        'price': price,
        'stock': stock
    })
    # перенаправляем на страницу со списком товаров
    # ОБЯЗАТЕЛЬНО указываем status_code=303, чтобы произошел редирект,
    # но с методом GET на новый URL (по умолчанию возвращается 307, с ним будет ошибка)
    return RedirectResponse(url='/products', status_code=303)

# Задание № 11 - переместить add_product.html в папку /templates

'''
Эндпоинты добавили, теперь идем к HTML-файлу. Перенесем add_product.html из папки /static
в папку /templates, как это сделали ранее для products.html.
'''

# Задание № 12 - внести изменения в add_product.html

'''
После переноса внесем в файл следующие правки:

1) В строке <a href="/static/products.html">Список</a> поменяем путь на "/products",
чтобы ссылка на список с товарами работала корректно.
2) Для открывающего тега <form> внутри добавим action="/products/create" и method="post",
получится <form action="/products/create" method="post">. Теперь форма будет отправлять
данные эндпоинту по адресу /products/create с помощью метода POST.
3) Для тегов <input> добавим параметр name, где укажем такие же имена, которые мы передавали
ранее в Form() внутри create_product(). Получится так:
...<input name="title" ...
...<input name="price" ...
...<input name="stock" ...
4) Для кнопки в теге <button> для параметра type укажем "submit", чтобы при нажатии на кнопку
данные из формы действительно отправлялись на сервер. Получится так:
<button type="submit">...

Готово! Теперь, если перейти по адресу http://127.0.0.1:8000/products/new, заполнить форму
и нажать кнопку "Отправить", то произойдет переадресация на http://127.0.0.1:8000/products, где
в таблице появится строчка с данными нового товара.
'''

# ---------------------------------------------------------------------------------------------------

# Преобразование index.html

# Задание № 13 - модифицировать эндпоинт root()
'''
Осталось разобраться со странице index.html. Для единообразия отредактируем эндпоинт root():
'''
@router.get('/', response_class=HTMLResponse)
async def root(request: Request):
    return templates.TemplateResponse(
        name='index.html',
        context={'request': request}
    )

# Задание № 14 - переместить add_product.html в папку /templates
'''
Теперь перенесем index.html из папки /static в папку /templates.

Если запустим приложение и перейдем по адресу http://127.0.0.1:8000/, то откроется
index.html, но кнопки "Список товаров" и "Добавить товар" работать не будут.
Для этого нужно отредактировать ссылки, указанный в кнопках, а точнее - в параметрах href:
'''

# Задание № 15 - модифицировать ссылки во всех HTML-файлах

'''
  <p><a class="button" href="/products">Список товаров</a></p>
  <p><a class="button" href="/products/new">Добавить товар</a></p>

А заодно и не забудем отредактировать остальные ссылки в кнопках на других страницах:

add_product.html:
      <a href="/">Главная</a>
    
products.html:
      <a href="/">Главная</a>
      <a href="/products/new">Добавить</a>

Супер, теперь все ссылки работают корректно 😎
'''