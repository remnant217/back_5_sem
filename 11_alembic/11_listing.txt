# Миграции Alembic

'''
План урока:
1) Введение
2) Доработка кода с предыдущего занятия
3) Введение в систему миграций и Alembic
4) Установка и настройка Alembic
5) Создание и применение миграций
6) Изменение модели и миграции
7) Заключение
'''

# Доработка кода с предыдущего занятия
'''
На предыдущем занятии мы познакомились с технологией ORM, которая позволяет связывать
вместе программные объекты и реляционные базы данных. Также мы поработали с библиотекой
SQLAlchemy и научились выполнять CRUD-операции в контексте баз данных.
В конце мы соединили наш проект product_catalog и SQLAlchemy, в результате чего
данные теперь хранятся не в оперативной памяти программы, а в БД.

СОВЕТ ПРЕПОДАВАТЕЛЮ: если на предыдущем занятии вы не успели до конца модифицировать 
проект product_catalog - крайне рекомендуется выделить время и дописать программный код.
В любом случае рекомендуется напомнить студентам текущую структуру приложения с учетом наличия БД.
Особое внимание обратите на модули database.py и models.py.
'''

# -------------------------------------------------------------------------------------------------------------

# Введение в систему миграций и Alembic
'''
Итак, у нас есть проект с FastAPI-приложением и подключенной БД через SQLAlchemy.
Мы умеем создавать модели, работать с CRUD-операциями и сохранять данные с помощью SQLite.
Но возникает вопрос:"Что делать, если нужно поменять структуру таблицы?"
Например:
- Добавить новое поле в таблицу
- Удалить ненужное поле
- Изменить тип столбца

Мы можем сделать это вручную - поменять код модели и пересоздать базу.
Но с таким подходом возникнут проблемы и вот почему:
- Можно потерять данные
- Усложняется работа в команде
- Сложно отслеживать, какие изменения вносились и когда

Возникает потребность в инструменте, который:
- Фиксирует изменения схемы БД
- Умеет откатывать изменения назад
- Помогает работать в команде, чтобы все разработчики имели одинаковую структуру БД

Отсюда и появился механизм миграций.

Миграция - инструкции, описывающие, как изменить схему базы данных
(добавить столбец, создать новую таблицу и т.д.)

Каждая миграция хранится в специальной истории изменений.
В миграции есть две части:
- upgrade - применить изменения
- downgrade - отменить изменения

Аналогия с Git:
Механизм миграций напоминает систему контроля версий Git. Там фиксируются изменения в программных файлах.
В миграциях также фиксируются изменения, но уже в базе данных.

Одной из самых популярных библиотек для реализации миграций является Alembic.

Alembic - библиотека для управления миграциями баз данных, использующая SQLAlchemy.
Как работает Alembic:
1) Смотрит на имеющиеся модели (Base и таблицы)
2) Сравнивает их с текущей схемой БД
3) Генерирует миграции

Основные возможности Alembic:
- Хранение истории изменений схемы БД
- Автоматическая генерация миграций
- Ручное редактирование скрипта миграции при необходимости
- Выполнение миграций в рамках транзакций
- Поддержка различных СУБД

models.py (SQLAlchemy) ───► Alembic ───► база данных
                        ▲             ▼
        (генерация миграции)   (upgrade/downgrade)

Важность миграций:
- В реальных проектах пользователя постоянно взаимодействуют с БД
- Пересоздать БД заново = потерять данные = недовольные пользователи
- У всех разработчиков находится нужная версия БД
'''

# -------------------------------------------------------------------------------------------------------------

# Установка и настройка Alembic

# Задание № 1 - установить библиотеку alembic
'''
Alembic - сторонняя библиотека, установим ее через pip внутри виртуального окружения нашего проекта product_catalog:
pip install alembic
'''

# Задание № 2 - провести инициализацию Alembic и изучить появившиеся файлы
'''
Для инициализации Alembic выполним в терминале следующую команду:
alembic init migrations

После выполнения в папке проекта появятся следующие файлы:
migrations/
    env.py              # настройка подключения к БД и импорт моделей
    README              # README-файл от Alembic
    script.py.mako      # Шаблон, по которому Alembic будет создавать новые миграции в папке versions/
    versions/           # папка, где будут храниться все миграции
alembic.ini             # главный файл конфигурации 
'''

# Задание № 3 - настроить файл alembic.ini
'''
Откроем alembic.ini и найдем строку:
sqlalchemy.url = driver://user:pass@localhost/dbname

Заменим ее на путь к нашей SQLite-базе:
sqlalchemy.url = sqlite:///./products.db

Так мы указываем DSN (Data Source Name) для подключения Alembic к базе.
'''

# Задание № 4 - настроить файл env.py
'''
По умолчанию Alembic ничего не знает про наши модели SQLAlchemy.
Нужно показать ему объекты Base и engine из нашего проекта.

В файле migrations/env.py заменим/добавим следующий код:
'''
# подключаем объекты Base и engine
from database import Base, engine
# импортируем модели проекта
import models
...
# указываем, какие таблицы и модели нужно отслеживать для миграций
target_metadata = Base.metadata

# Задание № 5 - проверить настройки Alembic
'''
Для проверки, что все настроено корректно, выполним в терминале следующую команду:
alembic revision --autogenerate -m "init db"

revision - создать новый файл миграции
--autogenerate - включить автогенерацию на основе различий между моделями (Base.metadata) и схемой БД.
Без --autogenerate Alembic создаст пустой шаблон миграции, тогда код в upgrade()/downgrade() нужно писать вручную
-m "init db" - сообщение, которое попадет в название миграции, чтобы было понятно, для чего она

В результате выполнения в migrations/versions/ появился новый файл - значит Alembic работает правильно
и видит наши модели. В этом файле можно увидеть функции upgrade() и downgrade(), но они пустые, т.к.
мы пока не вносили никаких изменений в модели.

При этом в файле БД products.bd появилась новая таблица - alembic_version.
Она нужна Alembic, чтобы знать, какая версия миграции применена сейчас к БД. В этой таблице всегда 
одна колонка - version_num. В этом поле хранится идентификатор последней примененной миграции.
'''

# -------------------------------------------------------------------------------------------------------------

# Создание и применение миграций

# Задание № 6 - создать модель для новой таблицы orders
'''
В нашей БД есть таблица products. Создадим новую таблицу - orders, где будет храниться информация о заказах.
Поля таблицы orders:
- id - ID заказа (первичный ключ)
- customer_name - имя покупателя
- total_price - сумма заказа
- product_id - внешний ключ, ссылается на id в таблице products

Откроем models.py и добавим новый класс Order:
'''
# ForeignKey - класс для определения зависимости между двумя столбцами
from sqlalchemy import Column, Integer, String, Float, Boolean, ForeignKey
# relationship() - функция для создания связи на уровне классов
from sqlalchemy.orm import relationship
from database import Base

class Product(Base):
    __tablename__ = 'products'

    id = Column(Integer, primary_key=True, index=True)  
    name = Column(String, nullable=False)
    description = Column(String, nullable=True)             
    price = Column(Float, nullable=False)            
    in_stock = Column(Boolean, default=True)

# модель таблицы заказов
class Order(Base):
    __tablename__ = 'orders'

    id = Column(Integer, primary_key=True, index=True)
    customer_name = Column(String, nullable=False)
    total_price = Column(Float, nullable=False)
    # создаем связь "один ко многим": заказ -> товары
    product_id = Column(Integer, ForeignKey('products.id'))
    # создаем связь с классом Product, объект Order сможет обращаться к полям Product напрямую
    product = relationship('Product')

# Задание № 7 - выполнить миграцию для появления таблицы orders в БД
'''
Если мы сейчас попробуем выполнить миграцию, то появится ошибка "FAILED: Target database is not up to date."
Дело в том, что ранее мы выполнили команду alembic revision --autogenerate -m "init db", но при этом не вызывали upgrade.
То есть файл миграции есть, а БД осталась в предыдущем состоянии.
Т.к. в БД уже есть таблица products с данными, мы скажем Alembic, что БД в актуальном состоянии. Для этого есть команда:
alembic stamp head

- stamp - команда для замены записи в таблице alembic_version, без запуска миграций
- head - указатель на последнюю миграцию
С ее помощью мы запишем в таблицу alembic_version идентификатор последней миграции.

Теперь Alembic будет считать базу синхронизированной, и можно спокойно делать новые миграции.
Выполним миграцию:
alembic revision --autogenerate -m "create orders table"

В папке migrations/versions/ появится файл, в названии которого будет ..._create_orders_table.py.
Внутри файла можно увидеть содержимое функций upgrade() и downgrade().
Теперь применим миграцию:
alembic upgrade head

После запуска в products.db появится новая таблица orders, связанная с products.

Если возникает необходимость откатить изменения, до для этого также есть команда:
alembic downgrade -1

-1 означает "откатиться на одну миграцию назад".
В результате применения команды будет удалена таблица orders.

При желании можно откатиться и дальше, указать конкретный идентификатор миграции:
alembic downgrade <revision_id>

<revision_id> - первые символы хэша из имени файла миграции

Вернемся обратно к последней версии, с таблицей orders:
alembic upgrade head
'''

# -------------------------------------------------------------------------------------------------------------

# Изменение модели и миграции

# Задание № 8 - добавить новое поле status в таблицу orders
'''
Ранее мы создали модель Order и с помощью миграции внесли ее в БД.
Представим, что нам нужно дополнить таблицу новым полем под названием status,
который будет хранить статус заказа (Новый, В обработке, Выполнен)
'''
class Order(Base):
    __tablename__ = 'orders'

    id = Column(Integer, primary_key=True, index=True)
    customer_name = Column(String, nullable=False)
    total_price = Column(Float, nullable=False)
    product_id = Column(Integer, ForeignKey('products.id'))
    product = relationship('Product')
    # новое поле со статусом заказа (по умолчанию - Новый)
    status = Column(String, default='Новый', nullable=False)
'''
Создадим файл миграции следующей командой:
alembic revision --autogenerate -m "add_status_column_to_orders"

В появившемся файле миграций функции upgrade() и downgrade() будут выглядеть примерно так:
'''
def upgrade() -> None:
    op.add_column('orders', sa.Column('status', sa.String(), nullable=False))

def downgrade() -> None:
    op.drop_column('orders', 'status')

'''
Запустим миграцию:
alembic upgrade head

В результате Alembic добавит колонку status в таблицу orders, а в таблице alembic_version обновится версия.
'''

# Задание № 9 - добавить новое поле delivery_address в таблицу orders
'''
Задание на самостоятельное выполнение:
1. Добавить в таблицу orders новое поле delivery_address - адрес доставка заказа (строка, обязательное)
2. Сгенерируйте миграцию с комментарием "add delivery_address column to orders"
3. Выполните миграцию
4. Проверьте, что поле появилось в таблице

Решение задания:
'''
# Шаг 1 - добавим в модель Order поле delivery_address
class Order(Base):
    __tablename__ = 'orders'

    id = Column(Integer, primary_key=True, index=True)
    customer_name = Column(String, nullable=False)
    total_price = Column(Float, nullable=False)
    product_id = Column(Integer, ForeignKey('products.id'))
    product = relationship('Product')
    status = Column(String, default='Новый', nullable=False)
    # новое поле с адресом доставки
    delivery_address = Column(String, nullable=False)

# Шаг 2 - сгенерируем миграцию с помощью команды:
# alembic revision --autogenerate -m "add delivery_address column to orders"

# Шаг 3 - выполним миграцию с помощью команды:
# alembic upgrade head

# Шаг 4 - зайдем в products.db, откроем таблицу orders и увидим новое поле delivery_address