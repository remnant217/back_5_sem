# Логирование в FastAPI

# Логирование - что, зачем, почему
'''
На предыдущем занятии мы изучали зависимости и middleware в FastAPI.
В конце урока мы создали middleware для подсчета времени выполнения запроса.
Выглядело это так:
'''
from fastapi import FastAPI, Request
from time import perf_counter

app = FastAPI()

@app.middleware('http')
async def add_process_time_header(request: Request, call_next):
    start_time = perf_counter()
    response = await call_next(request)
    process_time = perf_counter() - start_time
    response.headers['X-Process-Time'] = str(process_time)
    return response

'''
В этом коде мы сохраняли время выполнения запроса в заголовки ответа.
Но если вдруг мы хотим посмотреть на среднее время выполнения всех запросов?
Да еще и в разное время суток? Для этого нужно где-то хранить эти данные.
А вдруг вообще запрос не выполнился и возникла ошибка, как часто такое происходит?
И в чем именно ошибка? Как видите, вопросов появляется все больше и популярным ответов
на них является использование логирования.

Логирование - процесс записи и хранения информации о событиях, действиях и состояниях
системы, приложений или пользователей. Хранимые записи называются логами.

Примеры логирования:
1) Анализ производительности - в логах может храниться информация о производительности
приложения. Анализ такой информации помогает выявлять проблемные места приложения и 
области для возможной оптимизации.

2) Диагностика и отладка - если возникают сбои или ошибки, логи помогают в понимании причины
проблемы и ее устранении.

3) Мониторинг - с помощью логов можно отслеживать состояние системы в реальном времени
для выявления возможных проблем.

4) Безопасность - в логах можно фиксировать действия системных процессов и пользователей,
что может помочь при устранении проблем.
'''

# ----------------------------------------------------------------------------------------------------------

# Введение в loguru
'''
Для работы с логированием существует множество инструментов и библиотек.
Сегодня мы познакомимся с библиотекой loguru и научимся с ее помощью настраивать логирование
в наших FastAPI-приложениях.

loguru - библиотека языка Python для удобного ведения логов в проекте.
https://loguru.readthedocs.io/en/stable/index.html - официальная документация loguru
'''

# Задание № 1 - установить библиотеку loguru
'''
Установка loguru:
pip install loguru
'''

# Задание № 2 - подключить объект logger в программу

# logger - объект для отправки сообщений с логами
from loguru import logger

'''
Одной из важных черт философии loguru является тот факт, что logger - это центральный объект loguru,
все настройки журнала логов и его использование проходят через вызов одного из методов объекта logger.
'''

# Задание № 3 - вывести в терминал приветственное информационное сообщение

# info() - метод для регистрации информационного сообщения 
logger.info('Привет от loguru!')

'''
При запуске кода в терминале увидим подобное сообщение:
2025-10-02 14:14:31.885 | INFO     | __main__:<module>:3 - Привет от loguru!

2025-10-02 14:14:31.885 - время регистрации сообщения
INFO - тип сообщения
__main__:<module>:3 - источник сообщения (имя модуля, область видимости, № строки)
Привет от loguru! - текст сообщения

В системе логирования loguru есть 7 уровней, расположенных по важности:

TRACE < DEBUG < INFO < SUCCESS < WARNING < ERROR < CRITICAL

TRACE - подробная информация о ходе выполнения программы (общая диагностика приложения)
DEBUG - детальная информация для отладки (только для разработки)
INFO - обычная работа программы (запуск сервера, обработка запросов и т.д.)
SUCCESS - похоже на INFO, но используется для указания успешности операции 
(успешное выполнение запроса пользователя, создание новой записи в БД и т.д.)
WARNING - что-то не так, но приложение продолжает работать (медленная обработка запроса, несовпадение версий библиотек и т.д.)
ERROR - ошибка, но приложение продолжает работать (неверные данные от пользователя, не удалось обновить ресурс в системе и т.д.)
CRITICAL - критическая ошибка, угрожающая нормальному функционированию всего приложения 
(отсутствует соединение с БД, нехватка памяти для хранения данных и т.д.)
'''

# Задание № 4 - создать сообщение каждого уровня и посмотреть на результат в терминале:

logger.trace('Сообщение трассировки')
logger.debug('Проводим дебаг модуля')
logger.info('Запускаем сервер')
logger.success('Сервер успешно запущен')
logger.warning('Сервер медленно обрабатывает запросы')
logger.error('Не удалось обновить ресурс')
logger.critical('Потеряно соединение с сервером')

'''
При запуске кода в терминале увидим подобное сообщение:

2025-10-02 16:33:27.996 | DEBUG    | __main__:<module>:4 - Проводим дебаг модуля
2025-10-02 16:33:27.996 | INFO     | __main__:<module>:5 - Запускаем сервер
2025-10-02 16:33:27.996 | SUCCESS  | __main__:<module>:6 - Сервер успешно запущен
2025-10-02 16:33:27.996 | WARNING  | __main__:<module>:7 - Сервер медленно обрабатывает запросы
2025-10-02 16:33:27.996 | ERROR    | __main__:<module>:8 - Не удалось обновить ресурс
2025-10-02 16:33:27.996 | CRITICAL | __main__:<module>:9 - Потеряно соединение с сервером

Обратите внимание, что TRACE-сообщение не было отображено. Связано это с тем, что по умолчанию
loguru использует уровень DEBUG в качестве минимального, что приводит к игнорированию любых логов
с уровнем ниже, чем DEBUG. Ниже мы увидим как можно изменить данное поведение.
'''

# Задание № 5 - сбросить стандартную настройку объекта logger и указать новую с помощью метода add()

# импортируем модуль sys для указания, чтобы логи выводились в терминал
import sys

# сбрасываем стандартные настройки объекта logger
logger.remove()

# add() - метод для собственной настройки объекта logger
logger.add(
    sink=sys.stderr,    # sys.stderr - файловый объект, соответствующий стандартному потоку ошибок
    level='TRACE',      # минимальный уровень отображения сообщений
    format='<green>{time}</green> | {level} | {message}',      # шаблон, используемый для форматирования логов перед отправкой
    colorize=True       # цветной вывод (если указаны цвета)
)

'''
При запуске кода в терминале увидим подобное сообщение:

2025-10-02T17:35:40.728459+0500 | TRACE | Сообщение трассировки
2025-10-02T17:35:40.728459+0500 | DEBUG | Проводим дебаг модуля
2025-10-02T17:35:40.728459+0500 | INFO | Запускаем сервер
2025-10-02T17:35:40.728459+0500 | SUCCESS | Сервер успешно запущен
2025-10-02T17:35:40.728459+0500 | WARNING | Сервер медленно обрабатывает запросы
2025-10-02T17:35:40.728459+0500 | ERROR | Не удалось обновить ресурс
2025-10-02T17:35:40.728459+0500 | CRITICAL | Потеряно соединение с сервером

Параметр format можно настроить разными способами под собственные нужды.

Очень часто логирование происходит при работе функций. Посмотрим как можно внедрять логирование в функции.
'''

# Задание № 6 - создать простую функцию для валидации имени пользователя и настроить метод add()

# обновим метод add()
logger.add(
    sink=sys.stderr,
    level='DEBUG',
    format='<green>{time:HH:mm:ss}</green> | <level>{level:8}</level> | {name}:<cyan>{function}</cyan> | <level>{message}</level>',
    colorize=True
)
'''
<green>{time:HH:mm:ss}</green> - время в формате "часы:минуты:секунды" (например, 18:36:13) зеленого цвета
<level>{level:8}</level> - тег <level> преобразует текст в соответствии с цветом уровня важности, :8 - выравнивание до 8 символов
{name} - имя модуля, откуда была инициирована запись лога
<cyan>{function}</cyan> - тег <cyan> обозначает бирюзовый цвет, {function} хранит имя функции, где была инициирована запись лога
{message} - сообщение лога
'''

# функция валидации имени пользователя
def is_valid_name(user_id, name):
    logger.info(f'Обрабатываем пользователя {user_id}')

    if len(name) < 2:
        logger.warning(f'Слишком короткое имя: {name}')
        return False
    
    logger.debug(f'Имя корректно: {name}')
    return True

# протестируем работу логов
print(is_valid_name(123, 'Иван'))
print(is_valid_name(124, 'А'))

'''
При запуске программы увидим подобные логи:
20:41:51 | INFO     | __main__:is_valid_name | Обрабатываем пользователя 123
20:41:51 | DEBUG    | __main__:is_valid_name | Имя корректно: Иван
True
20:41:51 | INFO     | __main__:is_valid_name | Обрабатываем пользователя 124
20:41:51 | WARNING  | __main__:is_valid_name | Слишком короткое имя: А
False

Когда приложение выходит на стадию продакшена, то логи в терминале быстро пропадают.
Решение - хранить логи в специальных файлах. Но с ними тоже не все гладко - у высоконагруженного
приложения логи будут накапливаться довольно быстро, от чего файлы также будут сильно увеличиваться
в размерах. А если файл с логами будет слишком большой - проводить поиск и анализ может быть неудобно.
К тому же, чем старее файл с логами, тем с меньшей долей вероятности от может пригодиться. Значит
хранить логи вообще за все время работы приложения тоже нет особого смысла.

Для решения этих проблем в методе logger.add() есть специальные параметры:
1) rotation - когда создавать новый лог-файл
Примеры:
- 10 MB - каждые 10 мегабайт
- 12:00 - ежедневно в 12:00
- 1 week - 1 раз в неделю

2) retention - как долго нужно хранить лог-файлы
Пример - 5 days - после 5 дней лог-файлы будут очищаться

3) compression - формат сжатия или архивации лог-файлов после их закрытия
Пример - zip - преобразовывать заполненные логи в ZIP-файлы
'''

# Задание № 7 - настроить новые параметры в методе add() и реализовать сохранение
# логов в лог-файл, находящийся внутри папки logs/

# импортируем модуль os для создания папки logs/ в коде
import os

# создаем папку для хранения логов (если папка уже существует - новая не создается)
os.makedirs('logs', exist_ok=True)

# не забываем сбросить стандартные настройки logger-а
logger.remove()

# указываем новые настройки 
logger.add(
    sink='logs/app.log',    # файл, куда сохранять логи
    level='INFO',
    # убираем теги в параметр format, иначе логи запишутся с лишними символами
    format='{time:HH:mm:ss} | {level:8} | {name}:{function} | {message}',
    rotation='100 KB',    # новый файл каждые 100 килобайт
    retention='1 day',    # обновлять файлы с логами каждый день
    compression='zip'     # сжимать старые файлы в формат ZIP
)

# генерируем много логов для тестирования
for i in range(1000):
    logger.info(f'Тестовое сообщение № {i}')

    if i % 100 == 0:
        logger.warning(f'Каждое сотое сообщение - предупреждение, № {i}')

'''
После запуска кода в папке logs/ появятся следующие файлы:
- app.log - файл с последними логами
- app.2025-10-03_13-16-40_891456.log.zip (название будет другое) - архив со старыми логами

СОВЕТ ПРЕПОДАВАТЕЛЮ: обязательно откройте лог-файлы и обсудите со студентами их содержимое.
'''

# ----------------------------------------------------------------------------------------------------------

# Интеграция loguru и FastAPI
'''
В реальных проектах нередко используются сразу несколько видов логирования:
- в консоль (для разработчиков)
- в файле (для продакшена)

loguru позволяет для объект logger вызвать метод add() несколько раз, 
настраивая каждый источник сохранения логов.

Создадим отдельный файл logging_app.py, где реализуем функцию setup_logging() c настройками логирования проекта.
Внутри функции реализуем 3 вида логирования:
- в консоль - для разработчиков
- в logs/app.log - все логи уровня INFO и выше
- в logs/errors.log - логи с ошибками
'''

# Задание № 8 - реализовать файл logging_app.py

from loguru import logger
import os
import sys

# настройка источников логирования для проекта
def setup_logging():
    logger.remove()

    # логирование в консоль
    logger.add(
        sink=sys.stderr,
        level='DEBUG',
        format='<green>{time:HH:mm:ss}</green> | <level>{level:8}</level> | {name}:<cyan>{function}</cyan> | <level>{message}</level>',
        colorize=True
    )

    # подготавливаем папку для хранения лог-файлов
    os.makedirs('logs', exist_ok=True)

    # логирование в logs/app.log (все логи)
    logger.add(
        sink='logs/app.log',
        level='INFO',
        # line - показывает номер строчки в файле, откуда было вызвано сохранение лога
        format='{time:HH:mm:ss} | {level:8} | {name}:{function}:{line} | {message}',
        rotation='10 MB',    
        retention='7 days',    
        compression='zip',
    )

    # логирование в logs/errors.log (ошибки)
    logger.add(
        sink='logs/errors.log',
        level='ERROR',
        # exception - показывает возникшее исключение
        format='{time:HH:mm:ss} | {level:8} | {name}:{function}:{line} | {message}\n{exception}',
        rotation='10 MB',    
        retention='7 days',    
        compression='zip'
    )

'''
Затем идем в main.py, создадим экземпляр приложения FastAPI, несколько эндпоинтов и внедрим логирование.
'''
# Задание № 9 - реализовать файл main.py

from fastapi import FastAPI
# импортируем logger, чтобы сохранять логи внутри эндпонитов
from loguru import logger
from logging_app import setup_logging

# запускаем логирование в проекте
setup_logging()

app = FastAPI()

# обращение к корневому каталогу
@app.get('/')
async def root():
    logger.info('Вызван корневой эндпоинт')
    return {'message': 'Приложение с loguru работает корректно'}

# вычисление математического выражения
@app.get('/calc')
# получаем на вход строку с выражением (например, 2 + 2)
async def get_calc(expression: str):
    logger.info('Пользователь обратился к эндпоинту /calc')
    # пробуем вычислить выражение
    try:
        logger.info(f'Попытка вычислить выражение {expression}')
        # проводим вычисления
        result = eval(expression)
        logger.info(f'Результат вычисления: {result}')
        return {'result': f'Результат вычисления: {result}'}
    # если при вычислении возникла ошибка
    except Exception as e:
        logger.exception('При вычислении произошла ошибка')
        return {'error': f'При вычислении произошла ошибка: {e}'}

'''
Все готово, теперь идем тестировать код и проверять работу логирования.

СОВЕТ ПРЕПОДАВАТЕЛЮ: несколько советов при тестировании кода:
1) Обратите внимание студентов, что при запуске приложения в папке logs/ создаются пустые файлы app.log и errors.log
2) При тестировании GET /calc покажите хотя бы 1 пример успешного выполнения (например, 2 + 2). Покажите что отображается
в Swagger UI, затем в терминале, и в конце в app.log
3) При тестировании GET /calc покажите хотя бы 1 пример неуспешного выполнения (например, 2 / 0). Покажите что отображается
в Swagger UI, затем в терминале, и в конце в app.log. Также обратите внимание студентов, насколько подробно вывелась информация
об ошибке - полная трассировка всех операций, отдельно подписаны значения объектов и переменных.
'''