# Зависимости и middleware

'''
План урока:
1) Введение
2) Проблема дублирования кода при создании API
3) Внедрение зависимостей в FastAPI
4) Классы как зависимости
5) Middleware в FastAPI
6) Заключение
'''

# Проблема дублирования кода при создании API
'''
При создании API разработчик должен думать о многих вещах, вот некоторые из них:

1) Проверка API-ключа или токена
Зачем? Чтобы ограничить доступ только для авторизованных пользователей или сервисов.
Если нет проверки: любой человек сможет вызвать любой эндпоинт нашего API
и навредить системе, либо получить доступ к ценным данным.
Пример: есть внутренний API, которым пользуются только сотрудники конкретной компании.
Если не проверять API-ключ, доступ сможет получить кто угодно через Интернет.
Ключ выступает в роли фильтра:"Доступ только для сотрудников компании"

2) Логирование запросов
Зачем? Чтобы понимать, что реально происходит в приложении.
Если нет логирования: при жалобе со стороны клиентов "Сервис не работает, помогите, почините",
мы не сможем понять, какой запрос привел к ошибке.
Пример: в логах видно :"GET /users - 200", "POST /orders - 500". Значит ошибка при обработке заказов.
Логи помогают быстрее чинить баги и отслеживать подозрительные запросы.

3) Измерение времени ответа
Зачем? Чтобы контролировать производительность API
Если нет измерения: приложение может работать медленно, а мы даже об это не узнаем.
Пример: мы добавили новый эндпоинт, который, вроде как, работает. Вдруг в логах появляется
заголовок "X-Process-Time: 2.8s" (запрос выполнился за 2.8 сек.). Так мы понимаем,
что эндпоинт работает слишком долго и его надо оптимизировать.

4) Каждый раз открывать и закрывать подключение к базе данных
Зачем? Чтобы любой запрос к API имел свою сессию работы с БД:
- открываем соединение и выполняем запросы
- закрываем соединение, чтобы не перегружать БД
Если нет управления соединением:
- если не закрывать соединение - БД будет захламляться висящими без дела подключениями 
и в какой-то момент может перестатать принимать новые запросы
- если дублировать код открытия/закрытия сессии в каждом эндпоинте, то можно случайно
забыть закрыть сессию, создать две сессии и т.д.

На самом деле, дублирование кода может происходить во всех 4-х описанных ситуациях,
и чем такого повторяющего кода становится больше, тем выше вероятность допустить случайную ошибку,
из-за которой приложение будет работать нестабильно или перестанет работать вовсе.

Рассмотрим пример дублирующего кода с открытием/закрытием сессии в эндпоинтах (синхронный вариант):
'''
@app.get('/user')
def get_user(user_id: int):
    session = SessionLocal()        # открываем сессию
    user = session.get(user_id)
    session.close()                 # закрываем сессию
    return user

@app.get('/product')
def get_product(product_id: int):
    session = SessionLocal()        # код повторяется
    product = session.get(product_id)
    session.close()
    return product

'''
Видим, что один и тот же код повторяется в каждом эндпоинте.
Если эндпоинтов будет больше - дублирующегося кода станет слишком много.
Решение проблемы нам уже известно - создать завивимость через Depends(), которая сама откроет и закроет сессию.
Вот как мы это писали в коде:
'''
def get_session():
    session = SessionLocal()       # создаем новую сессию
    try:
        yield session              # отдаем ее в эндпоинт
    finally:
        session.close()            # после завершения запроса закрываем соединение

@app.get('/user')
def get_user(user_id: int, session: Session = Depends(get_session)):
    return session.get(user_id)

@app.get('/product')
def get_product(product_id: int, session: Session = Depends(get_session)):
    return session.get(product_id)
'''
Тогда код эндпоинтов будет более чистым, а соединения всегда будут корректно создаваться и освобождаться.

Хоть мы уже и использовали зависимости в коде, сегодня мы говорим о них более основательно и подробно, 
а затем познакомимся с концепцией middleware.
'''

# ----------------------------------------------------------------------------------------------------------

# Внедрение зависимостей в FastAPI
'''
В контексте FastAPI внедрение зависимостей можно трактовать так:
1) Зависимость - специальный механизм (функция, класс), который может использоваться кодом (эндпоинтами) для работы
2) Внедрение зависимости - предоставление коду (эндпоинтам) всего необходимого для использования зависимости

Внедрение зависимостей полезно, когда:
- Есть много повторяющего кода
- Производится подключение к базе данных
- Обеспечивается безопасность приложения, аутентификация пользователей и т.д.

Важно, что при этом происходит уменьшение дублирования кода.

Для лучшего понимания рассмотрим следующую ситуацию. Создадим два эндпоинта, каждый из которых
принимает 3 параметра и возвращает словарь с их значениями.

СОВЕТ ПРЕПОДАВАТЕЛЮ: для ускорения процесса можете отправить данный код студентам в чате.
'''

# Задание № 1 - создать эндпоинты get_products() и get_users() с похожей структурой 

from fastapi import FastAPI

app = FastAPI()

# получение списка товаров
@app.get('/products')
async def get_products(
    q: str | None = None,   # описание продукта
    page: int = 1,          # № страницы, с которой начинается поиск
    limit: int = 100        # ограничение на количество полученных товаров
) -> dict:
    return {'q': q, 'page': page, 'limit': limit}

# получение списка пользователей
@app.get('/users')
async def get_users(
    q: str | None = None,   # описание пользователя
    page: int = 1,          # № страницы, с которой начинается поиск
    limit: int = 100        # ограничение на количество полученных пользователей
) -> dict:
    return {'q': q, 'page': page, 'limit': limit}

'''
Видно, что логика эндпоинтов практически идентичная - получить одинаковые параметры
и вернуть словарь с их значениями. Конечно, это утрированный пример, но он показывает суть,
когда можно применить механизм внедрения зависимостей. Для этого создадим отдельную функцию,
куда вынесем повторяющуюся логику:
'''

# Задание № 2 - создать функцию-зависимость get_parameters()

async def get_parameters(
    q: str | None = None,
    page: int = 1,
    limit: int = 100
) -> dict:
    return {'q': q, 'page': page, 'limit': limit}

'''
Супер, эта функция и будет являться зависимостью, которую мы будем внедрять в наши эндпоинты.
Для этого подключим функцию Depends() и модифицируем код эндпоинтов:
'''

# Задание № 3 - внедрить созданную зависимость в эндпоинты

from fastapi import FastAPI, Depends

@app.get('/products')
async def get_products(parameters: dict = Depends(get_parameters)):
    return parameters

@app.get('/users')
async def get_users(parameters: dict = Depends(get_parameters)):
    return parameters

'''
Как видите, внедрение зависимости происходит за счет конструкции parameters: dict = Depends(get_parameters),
где в функцию Depends() передается единственный параметр - функция-зависимость. При этом мы не вызываем ее
напрямую (не указываем круглые скобки в конце), мы просто пишем get_parameters.

Таким образом, всякий раз, когда поступает новый запрос, FastAPI делает следующее:
- Вызывает функцию-зависимость с корректными параметрами
- Получает результат из функции-зависимости
- Присваивает результат параметру в эндпоинте

СОВЕТ ПРЕПОДАВАТЕЛЮ: обязательно запустите код и покажите, что эндпоинты работают корректно.

В рассмотренном примере с применением зависимости мы можем увидеть небольшое дублирование кода.
Когда нам нужно использовать функцию get_parameters() как зависимость, мы передаем ее как параметр
с аннотацией типа и функцией Depends:
'''
parameters: dict = Depends(get_parameters)

'''
Но мы можем вынести эту конструкцию в отдельную переменную и использовать ее везде, где нужно.
Для этого подключим специальный класс Annotated и с его помощью вынесем конструкцию 
parameters: dict = Depends(get_parameters) в отдельный объект:
'''

# Задание № 4 - сохранить зависимость в отдельную переменную

# Annotated - специальный класс, позволяющий указывать дополнительные метаданные в подсказках типов
from typing import Annotated

ParametersDep = Annotated[dict, Depends(get_parameters)] 

@app.get('/products')
async def get_products(parameters: ParametersDep):
    return parameters

@app.get('/users')
async def get_users(parameters: ParametersDep):
    return parameters

'''
Важный момент - использованный прием является стандартным для языка Python 
и называется "type alias" (псевдоним типа), это не какая-то специфичная вещь именно для FastAPI.
'''

# ----------------------------------------------------------------------------------------------------------

# Классы как зависимости
'''
В примере выше из функции зависимости мы возвращали словарь (экземпляр класса dict).
И затем этот же словарь передается в качестве параметра эндпоинтов. В такой ситуации мы ограничены
функциональностью класса dict и добавить новые методы или атрибуты будет проблематично.
Сейчас разберемся как можно решить эту проблему 😁

Ранее мы объявляли зависимость именно в виде функции. Но это не единственный способ работать с зависимостями
(хотя и наиболее популярный). Ключевым фактором является тот факт, что зависимость должна быть "callable" (вызываемой).
Вспомним, что "callable" в Python является все, что можно вызвать как функцию. Например, так:

func()

или так:

func(arg, key_arg='value')

Мы также прекрасно знаем, что объявление класса и создание его экземпляра в Python выглядит так:
'''
class Product:
    def __init__(self, name: str, price: int):
        self.name = name
        self.price = price

milk = Product(name='Молоко', price=100)

'''
Здесь milk является экземпляром класса Product.
И чтобы создать milk мы вызываем ("calling") класс Cat.
Отсюда делаем вывод - классы в Python являются "callable", а значит их можно использовать как зависимости в FastAPI.

Модифицируем наш код - заменим функцию get_parameters() на класс QueryParameters. Для этого в методе __init__() создадим
все те параметры, которые принимала и возвращала функция get_parameters():
'''

# Задание № 5 - создать класс QueryParameters

class QueryParameters:
    def __init__(
        self,
        q: str | None = None,
        page: int = 1,
        limit: int = 100
    ):
        self.q = q
        self.page = page
        self.limit = limit

'''
Перед тем, как будем присоединять класс QueryParameters как зависимость, создадим небольшой
список с товарами, имитирующий базу данных. Он нам пригодится для будущего тестирования эндпоинта:
'''

# Задание № 6 - создать список products_db

products_db = [
    {'product_name': 'Молоко'},
    {'product_name': 'Хлеб'},
    {'product_name': 'Телефон'},
    {'product_name': 'Куртка'}
]

'''
Теперь обратимся к эндпоинту get_products() и в его заголовке укажем новую зависимость через класс QueryParameters.
Будем использовать конструкцию через Annotated, которая рекомендуется в официальной документации FastAPI:
'''

# Задание № 7 - внедрить класс QueryParameters как зависимость в эндпоинт get_products()

@app.get('/products')
async def get_products(parameters: Annotated[QueryParameters, Depends(QueryParameters)]):
    return parameters

'''
Готово, зависимость указана. Теперь обновим тело эндпоинта - добавим работу с параметрами
q, page и limit:
'''

# Задание № 8 - обновить тело эндпоинта get_products()

@app.get('/products')
async def get_products(parameters: Annotated[QueryParameters, Depends(QueryParameters)]):
    response = {}       # словарь с ответом от API
    if parameters.q:    # если был передан параметр q
        response.update({'q': parameters.q})    # добавляем в словарь значение q
    # получаем нужные данные из products_db согласно указанным page и limit
    products = products_db[parameters.page:parameters.page + parameters.limit]
    response.update({'products': products})     # добавляем выгруженные продукты в словарь
    return response     # возвращаем ответ от API

'''
СОВЕТ ПРЕПОДАВАТЕЛЮ: обязательно запустите код и покажите, что эндпоинт работает корректно.

Давайте внимательно взглянем на строчке с внедрением зависимости:
'''
parameters: Annotated[QueryParameters, Depends(QueryParameters)]

'''
Видим, что класс QueryParameters указан дважды.
Важно понимать, что именно 2-е указание QueryParameters, то есть Depends(QueryParameters) - именно тут
FastAPI узнает что именно является зависимостью. Чтобы избежать такого дублирования, когда зависимость - это класс,
который FastAPI будет вызывать для создания экземпляра этого же класса, можно написать так:
'''
parameters: Annotated[QueryParameters, Depends()]

'''
В таком случае FastAPI логика кода сохранится и конструкция будет не такой громоздкой.
'''

# ----------------------------------------------------------------------------------------------------------

# Middleware в FastAPI
'''
Middleware ("Промежуточный слой") в контексте FastAPI - функция, которая выполняется до и после обработки каждого HTTP-запроса.

Общий алгоритм работы Middlware:
1) Принимает каждый запрос, приходящий в приложение
2) Выполняет некоторые действия с запросом или запускает любой необходимый код
3) Передает запрос дальше для обработки (например, в эндпоинт)
4) Принимает сгенерированный ответ (например, от эндпоинта)
5) Выполняет некоторые действия с ответом или запускает любой необходимый код
6) Возвращает окончательную версию ответа

Для создания собственного middleware, работающего с HTTP-запросами, используется декоратор @app.middleware('http').
При этом middleware-функция получает следующие переметры:
- request - входящий запрос
- call_next - функция, которая получит request в качестве параметра:
- - Сначала call_next передаст запрос на обработку (например, эндпоинту)
- - Затем call_next вернет ответ, сгенерированный обработчиком запроса (например, эндпоинтом)

Для примера создадим middleware, который замеряет время обработки запроса и добавляет 
этот показатель в заголовок ответа. 
Обратите внимание, что middlware лучше объявлять сразу после app = FastAPI() и до эндпоинтов.
Такая структура кода помогает контролировать порядок слов и упрощает чтение кода.
'''

# Задание № 9 - создать middleware для замера времени обработки запроса 

# подключаем функцию для измерения времени работы кода
from time import perf_counter
# Request - класс для работы с содержимым HTTP-запроса  
from fastapi import FastAPI, Request

app = FastAPI()

# регистрируем middleware для всего приложения, будет срабатывать с каждым запросом 
@app.middleware('http')
# объявляем middleware-функцию, принимающую запрос и функцию call_next для дальнейшей обработки запроса
async def add_process_time_header(request: Request, call_next):
    # замеряем начало обработки запроса
    start_time = perf_counter()
    # передаем запрос для дальнейшей обработки и получаем ответ
    response = await call_next(request)
    # вычисляем длительность обработки запроса
    process_time = perf_counter() - start_time
    # добавляем в заголовки ответа заголовок X-Process-Time (является общепринятым HTTP-заголовком)
    # по стандарту HTTP заголовки передаются в виде строк
    response.headers['X-Process-Time'] = str(process_time)
    # возвращаем модифицированный ответ клиенту
    return response

'''
СОВЕТ ПРЕПОДАВАТЕЛЮ: убедитесь, что все студенты создали add_process_time_header() в нужном месте.
Это радикально не повлияет на работу кода, но приучит к хорошему стилю оформления.

Протестируем работу нашего приложения:
http://127.0.0.1:8000/products?q=some_docs&page=1&limit=100

В Swagger UI, в разделе Response headers среди всех заголовков появится новый:
x-process-time: 0.004022499997518025

Если мы еще несколько раз протестируем эндпоинт, то увидим другие значения времени выполнения,
но все они будут в рамках нескольких миллисекунд.

Как итог, чтобы понимать, когда лучше использовать зависимости, а когда – middleware, можно следовать такому правилу:
- Если логика привязана к конкретным эндпоинтам и ее результат нужен в этих эндпоинтах – используем зависимости.
- Если логика общая и не привязана к конкретному эндпоинту – используем middleware
'''